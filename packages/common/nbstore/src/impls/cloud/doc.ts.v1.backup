import type { Socket } from 'socket.io-client';

import {
  type DocClock,
  type DocClocks,
  DocStorageBase,
  type DocStorageOptions,
  type DocUpdate,
} from '../../storage';
import { getIdConverter, type IdConverter } from '../../utils/id-converter';
import { getOrCreateSessionId } from '../../utils/session-id';
import type { SpaceType } from '../../utils/universal-id';
import {
  base64ToUint8Array,
  type ServerEventsMap,
  SocketConnection,
  uint8ArrayToBase64,
} from './socket';
import {
  emitSessionActivity,
  sanitizeSessionIdentifier,
} from '../../utils/session-activity';
import { getSocketIOUrl } from '@yunke/config';

/**
 * å°†APIåŸºç¡€URLè½¬æ¢ä¸ºSocket.IO URL
 * ä½¿ç”¨ç»Ÿä¸€çš„ç½‘ç»œé…ç½®ç®¡ç†ï¼Œä¸å†ç¡¬ç¼–ç ç«¯å£
 */
function convertToSocketIOUrl(_baseUrl: string): string {
  // ç›´æ¥ä½¿ç”¨ç»Ÿä¸€çš„ç½‘ç»œé…ç½®ç®¡ç†
  return getSocketIOUrl();
}

interface CloudDocStorageOptions extends DocStorageOptions {
  serverBaseUrl: string;
  isSelfHosted: boolean;
  type: SpaceType;
}

export class CloudDocStorage extends DocStorageBase<CloudDocStorageOptions> {
  static readonly identifier = 'CloudDocStorage';

  private readonly sessionId = getOrCreateSessionId();

  get socket() {
    return this.connection.inner.socket;
  }
  get idConverter() {
    if (!this.connection.idConverter) {
      throw new Error('IDè½¬æ¢å™¨æœªåˆå§‹åŒ–');
    }
    return this.connection.idConverter;
  }
  readonly spaceType = this.options.type;

  onServerUpdate: ServerEventsMap['space:broadcast-doc-update'] = message => {
    if (
      this.spaceType === message.spaceType &&
      this.spaceId === message.spaceId
    ) {
      const sessionId = sanitizeSessionIdentifier(message.sessionId);
      const clientId = sanitizeSessionIdentifier(message.clientId);
      const editorId = sanitizeSessionIdentifier(message.editor);
      
      // ğŸ”§ ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±å‘é€çš„æ›´æ–°ï¼Œé¿å…å¾ªç¯
      const normalizedSessionId = sanitizeSessionIdentifier(this.sessionId);
      const normalizedClientId = sanitizeSessionIdentifier(this.connection.clientId);
      
      // å¦‚æœ sessionId æˆ– clientId åŒ¹é…ï¼Œè¯´æ˜æ˜¯è‡ªå·±å‘é€çš„æ›´æ–°ï¼Œè·³è¿‡
      const isOwnUpdate = 
        (sessionId && normalizedSessionId && sessionId === normalizedSessionId) ||
        (clientId && normalizedClientId && clientId === normalizedClientId);
      
      if (isOwnUpdate) {
        // ğŸ”§ è‡ªå·±å‘é€çš„æ›´æ–°ï¼Œä¸è§¦å‘äº‹ä»¶ï¼Œé¿å…å¾ªç¯
        return;
      }

      this.emit('update', {
        docId: this.idConverter.oldIdToNewId(message.docId),
        bin: base64ToUint8Array(message.update),
        timestamp: new Date(message.timestamp),
        editor: sessionId ?? clientId ?? editorId ?? undefined,
        sessionId: sessionId ?? undefined,
        clientId: clientId ?? undefined,
      });

      if (sessionId) {
        emitSessionActivity({
          sessionId,
          clientId,
          source: 'remote',
        });
      }
    }
  };

  onServerUpdateBatch: ServerEventsMap['space:broadcast-doc-updates'] = message => {
    if (
      this.spaceType === message.spaceType &&
      this.spaceId === message.spaceId
    ) {
      // ğŸ”§ ä¿®å¤ï¼šæ‰¹é‡æ›´æ–°ä¹Ÿæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±å‘é€çš„
      const normalizedSessionId = sanitizeSessionIdentifier(this.sessionId);
      const normalizedClientId = sanitizeSessionIdentifier(this.connection.clientId);
      
      message.updates.forEach(update => {
        const sessionId = sanitizeSessionIdentifier(update.sessionId);
        const clientId = sanitizeSessionIdentifier(update.clientId);
        
        // å¦‚æœ sessionId æˆ– clientId åŒ¹é…ï¼Œè¯´æ˜æ˜¯è‡ªå·±å‘é€çš„æ›´æ–°ï¼Œè·³è¿‡
        const isOwnUpdate = 
          (sessionId && normalizedSessionId && sessionId === normalizedSessionId) ||
          (clientId && normalizedClientId && clientId === normalizedClientId);
        
        if (isOwnUpdate) {
          // ğŸ”§ è‡ªå·±å‘é€çš„æ›´æ–°ï¼Œè·³è¿‡
          return;
        }
        
        this.onServerUpdate({
          spaceType: update.spaceType ?? message.spaceType,
          spaceId: update.spaceId ?? message.spaceId,
          docId: update.docId ?? message.docId,
          update: update.update,
          timestamp: update.timestamp,
          editor: update.editor ?? '',
          sessionId: update.sessionId,
          clientId: update.clientId,
        });
      });
    }
  };

  readonly connection = new CloudDocStorageConnection(
    this.options,
    this.onServerUpdate,
    this.onServerUpdateBatch
  );

  override async getDocSnapshot(docId: string) {
    const res = await this.socket.emitWithAck('space:load-doc', {
      spaceType: this.spaceType,
      spaceId: this.spaceId,
      docId: this.idConverter.newIdToOldId(docId),
    });

    if ('error' in res) {
      if (res.error.name === 'DOC_NOT_FOUND') {
        // console.warn('[CloudDocStorage] load-doc: not found', { docId });
        return null;
      }
      throw new Error(res.error.message);
    }

    const missingBin = base64ToUint8Array(res.data.missing);

    return {
      docId,
      bin: missingBin,
      timestamp: new Date(res.data.timestamp),
    };
  }

  override async getDocDiff(docId: string, state?: Uint8Array) {
    const res = await this.socket.emitWithAck('space:load-doc', {
      spaceType: this.spaceType,
      spaceId: this.spaceId,
      docId: this.idConverter.newIdToOldId(docId),
      stateVector: state ? await uint8ArrayToBase64(state) : undefined,
    });

    if ('error' in res) {
      if (res.error.name === 'DOC_NOT_FOUND') {
        console.warn('[CloudDocStorage] diff: not found', { docId });
        return null;
      }
      throw new Error(res.error.message);
    }

    const missing = base64ToUint8Array(res.data.missing);
    const stateBin = base64ToUint8Array(res.data.state);

    return {
      docId,
      missing,
      state: stateBin,
      timestamp: new Date(res.data.timestamp),
    };
  }

  override async pushDocUpdate(update: DocUpdate) {
    const normalizedSessionId =
      sanitizeSessionIdentifier(update.sessionId) ?? this.sessionId;
    const normalizedClientId =
      sanitizeSessionIdentifier(update.clientId) ??
      sanitizeSessionIdentifier(this.connection.clientId ?? undefined) ??
      undefined;
    update.sessionId = normalizedSessionId;
    update.clientId = normalizedClientId ?? undefined;
    const updateBase64 = await uint8ArrayToBase64(update.bin);
    const docId = this.idConverter?.newIdToOldId(update.docId) || update.docId;

    // ä¼˜å…ˆä½¿ç”¨å…¨å±€äº‘å­˜å‚¨ç®¡ç†å™¨ï¼ˆè‹¥å¯ç”¨ï¼‰
    try {
      const cloudStorageManager = (window as any).__CLOUD_STORAGE_MANAGER__;

      if (cloudStorageManager && cloudStorageManager.isConnected && cloudStorageManager.pushDocUpdate) {
        const timestamp = await cloudStorageManager.pushDocUpdate(docId, update.bin);
        return { docId: update.docId, timestamp: new Date(timestamp) };
      }
    } catch (error) {
      // é™çº§åˆ° Socket.IO
    }

    // é™çº§åˆ°åŸå§‹Socket.IOæ–¹æ³•
    if (!this.connection.inner.socket?.connected) {
      throw new Error('Socket.IO connection not established');
    }

    try {
      const sessionId = sanitizeSessionIdentifier(update.sessionId) ?? this.sessionId;
      const clientId = sanitizeSessionIdentifier(update.clientId);

      emitSessionActivity({
        sessionId,
        clientId,
        source: 'local',
      });

      const requestData = {
        spaceType: this.options.type,
        spaceId: this.spaceId,
        docId: docId,
        update: updateBase64,
        sessionId,
        clientId: clientId ?? undefined,
      };

      const result = await this.connection.inner.socket.emitWithAck('space:push-doc-update', requestData);

      if ('error' in result) {
        throw new Error(`Socket.IO error: ${result.error.message}`);
      }

      const timestamp = typeof result === 'object' && 'timestamp' in result 
        ? new Date((result as any).timestamp) 
        : new Date();

      return { docId: update.docId, timestamp };

    } catch (error) {
      throw error;
    }
  }

  /**
   * Just a rough implementation, cloud doc storage should not need this method.
   */
  override async getDocTimestamp(docId: string): Promise<DocClock | null> {
    // æœ€å°å®ç°ï¼šé€šè¿‡åŠ è½½æ–‡æ¡£è·å–æ—¶é—´æˆ³ï¼ˆåç«¯å¯æ‰©å±• space:load-doc-timestamps äº‹ä»¶ï¼‰
    const diff = await this.getDocSnapshot(docId);
    if (!diff) return null;
    return { docId, timestamp: diff.timestamp };
  }

  override async getDocTimestamps(after?: Date) {
    // é€šè¿‡ Socket æ‰¹é‡è·å–æ—¶é—´æˆ³
    const response = await this.socket.emitWithAck('space:load-doc-timestamps', {
      spaceType: this.spaceType,
      spaceId: this.spaceId,
      timestamp: after ? after.getTime() : undefined,
    });

    if ('error' in response) {
      console.error('âŒ [CloudDocStorage] è·å–æ—¶é—´æˆ³å¤±è´¥:', response.error);
      throw new Error(response.error.message);
    }

    const raw: Record<string, number> = response.data as any;
    const ret: DocClocks = {};
    for (const [oldId, ts] of Object.entries(raw || {})) {
      ret[this.idConverter.oldIdToNewId(oldId)] = new Date(ts);
    }
    return ret;
  }

  override async deleteDoc(docId: string) {
    // ä½¿ç”¨HTTP REST APIåˆ é™¤æ–‡æ¡£
    const oldDocId = this.idConverter.newIdToOldId(docId);
    
    const response = await fetch(`${this.options.serverBaseUrl}/api/workspaces/${this.spaceId}/docs/${oldDocId}`, {
      method: 'DELETE',
      headers: {
        'x-yunke-version': '0.17.0',
      },
      credentials: 'include',
    });

    if (!response.ok) {
      throw new Error(`Failed to delete doc: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'Failed to delete doc');
    }
  }

  protected async setDocSnapshot() {
    return false;
  }
  protected async getDocUpdates() {
    return [];
  }
  protected async markUpdatesMerged() {
    return 0;
  }
}

class CloudDocStorageConnection extends SocketConnection {
  public clientId: string | null = null;

  constructor(
    private readonly options: CloudDocStorageOptions,
    private readonly onServerUpdate: ServerEventsMap['space:broadcast-doc-update'],
    private readonly onServerUpdateBatch: ServerEventsMap['space:broadcast-doc-updates']
  ) {
    // ä½¿ç”¨ç»Ÿä¸€çš„ç«¯å£è½¬æ¢é€»è¾‘
    const socketUrl = convertToSocketIOUrl(options.serverBaseUrl);
    super(socketUrl, options.isSelfHosted);
  }

  idConverter: IdConverter | null = null;

  override async doConnect(signal?: AbortSignal) {
    const { socket, disconnect } = await super.doConnect(signal);

    try {
      const joinData = {
        spaceType: this.options.type,
        spaceId: this.options.id,
        clientVersion: BUILD_CONFIG.appVersion,
      };

      const res = await socket.emitWithAck('space:join', joinData);

      if ('error' in res) {
        console.error('âŒ [CloudDocStorageConnection] space:join å¤±è´¥:', res.error);
        throw new Error(res.error.message);
      }

      if ('data' in res && res.data) {
        this.clientId =
          sanitizeSessionIdentifier((res.data as { clientId?: string }).clientId) ?? null;
      } else {
        this.clientId = null;
        console.warn('âš ï¸ [CloudDocStorageConnection] space:join å“åº”ä¸­æ²¡æœ‰ clientId');
      }

      if (!this.idConverter) {
        try {
          this.idConverter = await this.getIdConverter(socket);
        } catch (error) {
          console.warn('âš ï¸ [CloudDocStorageConnection] idConverter åˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', error);
          // ä½¿ç”¨é»˜è®¤çš„èº«ä»½è½¬æ¢å™¨ä½œä¸ºåå¤‡
          this.idConverter = {
            newIdToOldId: (id: string) => id,
            oldIdToNewId: (id: string) => id,
          };
        }
      }

      socket.on('space:broadcast-doc-update', this.onServerUpdate);
      socket.on('space:broadcast-doc-updates', this.onServerUpdateBatch);

      return { socket, disconnect };
    } catch (e) {
      console.error('âŒ [CloudDocStorageConnection] doConnect å¤±è´¥:', {
        error: e instanceof Error ? e.message : String(e),
        stack: e instanceof Error ? e.stack : undefined
      });
      disconnect();
      throw e;
    }
  }

  override doDisconnect({
    socket,
    disconnect,
  }: {
    socket: Socket;
    disconnect: () => void;
  }) {
    socket.emit('space:leave', {
      spaceType: this.options.type,
      spaceId: this.options.id,
    });
    socket.off('space:broadcast-doc-update', this.onServerUpdate);
    socket.off('space:broadcast-doc-updates', this.onServerUpdateBatch);
    this.clientId = null;
    super.doDisconnect({ socket, disconnect });
  }

  async getIdConverter(socket: Socket) {
    return getIdConverter(
      {
        getDocBuffer: async id => {
          const response = await socket.emitWithAck('space:load-doc', {
            spaceType: this.options.type,
            spaceId: this.options.id,
            docId: id,
          });

          if ('error' in response) {
            if (response.error.name === 'DOC_NOT_FOUND') {
              return null;
            }
            // TODO: ä½¿ç”¨ [ç”¨æˆ·å‹å¥½é”™è¯¯]
            throw new Error(response.error.message);
          }

          const missingData = response.data.missing;
          if (!missingData || missingData === '') {
            return null;
          }

          const buffer = base64ToUint8Array(missingData);
          if (!buffer || buffer.length === 0) {
            return null;
          }

          return buffer;
        },
      },
      this.options.id
    );
  }
}

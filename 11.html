<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>白板手绘加载动画</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 1. 纸质/白板纹理背景 */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #F9FAFB;
            /* 微妙的点阵背景 */
            background-image: radial-gradient(#9CA3AF 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Inter', sans-serif;
            /* 使用更随意的字体 */
        }

        .loader-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        /* 画布区域 */
        .canvas-area {
            width: 240px;
            height: 240px;
            position: relative;
        }

        /* SVG 基础设置 */
        svg {
            overflow: visible;
        }

        /* 通用路径样式 */
        .ink-path {
            fill: none;
            stroke: #374151;
            /* 深灰色铅笔/墨水色 */
            stroke-width: 2.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            /* 关键：应用手绘滤镜 */
            filter: url(#roughPaperFilter);
            opacity: 0.9;
        }

        /* 重点强调的笔触（如对勾） */
        .bold-ink {
            stroke: #059669;
            /* 绿色 */
            stroke-width: 4;
            opacity: 1;
        }

        /* 涂抹/擦除的笔触 */
        .scribble-ink {
            stroke: #DC2626;
            /* 红色或者是深乱色 */
            stroke-width: 2;
            opacity: 0.7;
        }

        /* 文字标注样式 */
        .handwritten-label {
            position: absolute;
            font-size: 14px;
            color: #4B5563;
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.3s ease;
            pointer-events: none;
            font-style: italic;
        }

        /* 加载提示词 */
        .status-text {
            margin-top: 1.5rem;
            font-size: 0.95rem;
            color: #6B7280;
            font-family: system-ui, -apple-system, sans-serif;
            letter-spacing: 0.05em;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div class="loader-container">
        <!-- SVG 滤镜定义：模拟纸张粗糙感和墨水渗开的效果 -->
        <svg width="0" height="0" style="position:absolute">
            <defs>
                <filter id="roughPaperFilter">
                    <!-- 产生噪点 -->
                    <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise" />
                    <!-- 稍微模糊一点噪点，让线条不那么尖锐 -->
                    <feGaussianBlur in="noise" stdDeviation="0.5" result="smoothedNoise" />
                    <!--以此扭曲源图像 -->
                    <feDisplacementMap in="SourceGraphic" in2="smoothedNoise" scale="4" xChannelSelector="R"
                        yChannelSelector="G" />
                </filter>
            </defs>
        </svg>

        <div class="canvas-area">
            <svg viewBox="0 0 100 100" width="100%" height="100%">

                <!-- 1. 想法 (圆形) -->
                <path id="circleIdea" class="ink-path"
                    d="M 50 10 C 30 10 15 25 15 40 C 15 60 35 65 50 65 C 70 65 85 55 85 35 C 85 20 70 10 50 10 Z"
                    style="display:none;" />

                <!-- 2. 连接线 (箭头) -->
                <path id="arrowLine" class="ink-path" d="M 50 65 Q 50 75 50 85" style="display:none;" />
                <path id="arrowHead" class="ink-path" d="M 45 80 L 50 88 L 55 80" style="display:none;" />

                <!-- 3. 原型 (方块) -->
                <path id="squareProto" class="ink-path" d="M 30 90 L 70 90 L 72 125 L 28 125 Z" style="display:none;" />

                <!-- 4. 否定 (涂鸦 Scribble) -->
                <path id="scribble" class="scribble-ink" style="display:none; filter: url(#roughPaperFilter);"
                    d="M 25 85 L 75 130 M 25 130 L 75 85 M 30 100 L 70 100 M 30 115 L 70 115" />

                <!-- 5. 成功 (对勾) -->
                <path id="checkMark" class="ink-path bold-ink" d="M 35 105 L 50 125 L 80 75" style="display:none;" />

            </svg>

            <!-- 动态出现的文字标签 -->
            <div id="label1" class="handwritten-label" style="top: 25px; left: 38px;">Idea</div>
            <div id="label2" class="handwritten-label" style="top: 100px; left: 35px;">Draft</div>
            <div id="label3" class="handwritten-label"
                style="top: 95px; left: 75px; color: #059669; font-weight:bold; font-size:16px">OK!</div>
        </div>

        <div class="status-text">正在梳理创意流程...</div>
    </div>

    <script>
        const els = {
            circle: document.getElementById('circleIdea'),
            line: document.getElementById('arrowLine'),
            arrow: document.getElementById('arrowHead'),
            square: document.getElementById('squareProto'),
            scribble: document.getElementById('scribble'),
            check: document.getElementById('checkMark'),
            lbl1: document.getElementById('label1'),
            lbl2: document.getElementById('label2'),
            lbl3: document.getElementById('label3')
        };

        // 动画序列主循环
        async function runAnimationSequence() {
            while (true) {
                // --- RESET ---
                resetAll();
                await wait(500);

                // --- STEP 1: 画圆 (Idea) ---
                await drawPath(els.circle, 600);
                showLabel(els.lbl1);
                await wait(300);

                // --- STEP 2: 画连接线 ---
                // 为了增加手绘感，我们这里实际上是让视窗稍微移动一点点（可选），或者只是画线
                await drawPath(els.line, 300);
                await drawPath(els.arrow, 200);

                // --- STEP 3: 画方块 (Draft) ---
                // 稍微重一点的笔触
                await drawPath(els.square, 500);
                showLabel(els.lbl2);
                await wait(600);

                // --- STEP 4: 涂抹/否定 (Scribble) ---
                // 快速且暴力的涂鸦
                await drawPath(els.scribble, 300);
                await wait(300);

                // --- STEP 5: 清除方块和涂鸦，显示对勾 ---
                // 模拟“擦除”效果：直接让它们透明度变低然后消失
                fadeElement(els.square);
                fadeElement(els.scribble);
                fadeElement(els.lbl2);
                await wait(200);

                // 画上对勾
                await drawPath(els.check, 400);
                showLabel(els.lbl3); // OK!

                // 稍微放大一下对勾表示强调
                els.check.style.transition = "transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
                els.check.style.transformOrigin = "50% 100%";
                els.check.style.transform = "scale(1.2)";

                await wait(1500);

                // 淡出所有内容准备下一次循环
                fadeOutAll();
                await wait(500);
            }
        }

        // 工具函数：模拟路径绘制
        function drawPath(element, duration) {
            return new Promise(resolve => {
                element.style.display = 'block';
                element.style.opacity = '1'; // 确保可见
                element.style.transform = 'scale(1)'; // 重置缩放

                const length = element.getTotalLength();

                // 初始状态：完全隐藏
                element.style.strokeDasharray = length;
                element.style.strokeDashoffset = length;

                // 强制重绘
                element.getBoundingClientRect();

                // 使用 Web Animation API 实现更平滑的控制
                const animation = element.animate([
                    { strokeDashoffset: length },
                    { strokeDashoffset: 0 }
                ], {
                    duration: duration,
                    easing: 'ease-out', // 模拟笔触：开始快，结束慢
                    fill: 'forwards'
                });

                animation.onfinish = resolve;
            });
        }

        function showLabel(el) {
            el.style.opacity = 1;
            el.style.transform = 'translateY(0)';
        }

        function hideLabel(el) {
            el.style.opacity = 0;
            el.style.transform = 'translateY(5px)';
        }

        function fadeElement(el) {
            el.style.transition = "opacity 0.3s ease";
            el.style.opacity = 0.2;
        }

        function fadeOutAll() {
            const allPaths = document.querySelectorAll('path');
            allPaths.forEach(p => {
                p.style.transition = "opacity 0.4s ease";
                p.style.opacity = 0;
            });
            Object.values(els).forEach(el => {
                if (el.tagName === 'DIV') hideLabel(el);
            });
        }

        function resetAll() {
            const allPaths = document.querySelectorAll('path');
            allPaths.forEach(p => {
                p.style.display = 'none';
                p.style.strokeDasharray = '';
                p.style.strokeDashoffset = '';
                p.style.transition = '';
                p.style.transform = '';
                p.style.opacity = 1;
            });
            Object.values(els).forEach(el => {
                if (el.tagName === 'DIV') hideLabel(el);
            });
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        window.onload = runAnimationSequence;

    </script>
</body>

</html>
# BlockSuite åˆ—å¸ƒå±€ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### 1. åˆ†å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  LayoutSwitcher â”‚  â”‚ LayoutRenderer  â”‚  â”‚ ColumnContentâ”‚ â”‚
â”‚  â”‚   (åˆ‡æ¢å™¨)       â”‚  â”‚   (æ¸²æŸ“å™¨)      â”‚  â”‚   (åˆ—å†…å®¹)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                    â”‚                    â”‚
            â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Service Layer                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PageLayoutServiceâ”‚  â”‚ColumnDistributorâ”‚  â”‚StorageServiceâ”‚ â”‚
â”‚  â”‚  (çŠ¶æ€ç®¡ç†)      â”‚  â”‚  (å†…å®¹åˆ†é…)     â”‚  â”‚  (æŒä¹…åŒ–)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                    â”‚                    â”‚
            â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Data Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  LayoutConfig   â”‚  â”‚  ColumnData     â”‚  â”‚  BlockData   â”‚ â”‚
â”‚  â”‚   (å¸ƒå±€é…ç½®)     â”‚  â”‚   (åˆ—æ•°æ®)      â”‚  â”‚  (å—æ•°æ®)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒæ¨¡å—èŒè´£

#### ğŸ›ï¸ Presentation Layer (è¡¨ç¤ºå±‚)
- **LayoutSwitcher**: ç”¨æˆ·äº¤äº’ç•Œé¢ï¼Œå¤„ç†å¸ƒå±€æ¨¡å¼åˆ‡æ¢
- **LayoutRenderer**: è´Ÿè´£æ ¹æ®æ¨¡å¼æ¸²æŸ“å¯¹åº”çš„å¸ƒå±€ç»“æ„
- **ColumnContent**: å•åˆ—å†…å®¹çš„æ¸²æŸ“å’Œäº¤äº’ç®¡ç†

#### âš™ï¸ Service Layer (æœåŠ¡å±‚)
- **PageLayoutService**: å¸ƒå±€çŠ¶æ€çš„ç»Ÿä¸€ç®¡ç†å’Œåè°ƒ
- **ColumnDistributor**: æ™ºèƒ½å†…å®¹åˆ†é…ç®—æ³•å®ç°
- **StorageService**: å¸ƒå±€é…ç½®çš„æŒä¹…åŒ–å­˜å‚¨

#### ğŸ’¾ Data Layer (æ•°æ®å±‚)
- **LayoutConfig**: å¸ƒå±€é…ç½®æ•°æ®ç»“æ„
- **ColumnData**: åˆ—ç›¸å…³çš„æ•°æ®æ¨¡å‹
- **BlockData**: Blockæ•°æ®çš„æ‰©å±•æ¥å£

## ğŸ”„ æ•°æ®æµè®¾è®¡

### 1. ç”¨æˆ·äº¤äº’æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant LS as LayoutSwitcher
    participant PLS as PageLayoutService
    participant CD as ColumnDistributor
    participant LR as LayoutRenderer
    participant SS as StorageService

    User->>LS: ç‚¹å‡»å¸ƒå±€æŒ‰é’®
    LS->>PLS: setLayoutMode(mode, docId)
    PLS->>SS: saveLayoutConfig(config)
    PLS->>CD: redistributeBlocks(mode)
    CD->>PLS: return columnBlocks[]
    PLS->>LR: renderLayout(mode, blocks)
    LR->>User: æ˜¾ç¤ºæ–°å¸ƒå±€
    PLS->>LS: notify mode changed
    LS->>User: æ›´æ–°æŒ‰é’®çŠ¶æ€
```

### 2. æ•°æ®æµå‘å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    setLayoutMode()    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User Action â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ PageLayoutServiceâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚ ColumnDistributorâ”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚  LayoutRenderer  â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚   DOM Update     â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§© æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. PageLayoutService (çŠ¶æ€ç®¡ç†æ ¸å¿ƒ)

```typescript
/**
 * é¡µé¢å¸ƒå±€æœåŠ¡ - ç³»ç»Ÿçš„çŠ¶æ€ç®¡ç†ä¸­å¿ƒ
 * 
 * èŒè´£:
 * - ç®¡ç†å½“å‰å¸ƒå±€æ¨¡å¼
 * - åè°ƒå„ä¸ªæœåŠ¡æ¨¡å—
 * - å¤„ç†å¸ƒå±€å˜åŒ–äº‹ä»¶
 * - æä¾›å¸ƒå±€ç›¸å…³çš„è®¡ç®—æœåŠ¡
 */
export class PageLayoutService {
  // === çŠ¶æ€ç®¡ç† ===
  private _layoutMode$ = signal<PageLayoutMode>(PageLayoutMode.Normal);
  private _columnWidths$ = signal<number[]>([1, 1, 1, 1, 1]);
  private _isTransitioning$ = signal<boolean>(false);
  
  // === ä¾èµ–æœåŠ¡ ===
  private distributor = new ColumnDistributor();
  private storage = new StorageService();
  private responsive = new ResponsiveManager();
  
  // === è®¡ç®—å±æ€§ ===
  readonly currentMode$ = computed(() => this._layoutMode$.value);
  readonly columnCount$ = computed(() => 
    LayoutModeConfig[this._layoutMode$.value].columns
  );
  readonly effectiveMode$ = computed(() => 
    this.responsive.getEffectiveMode(this._layoutMode$.value)
  );
  
  // === å…¬å…±æ–¹æ³• ===
  async setLayoutMode(mode: PageLayoutMode, docId: string): Promise<void> {
    if (this._isTransitioning$.value) return;
    
    this._isTransitioning$.value = true;
    
    try {
      // 1. è§¦å‘åˆ‡æ¢å‰äº‹ä»¶
      this._emitBeforeChange(this._layoutMode$.value, mode);
      
      // 2. æ›´æ–°çŠ¶æ€
      this._layoutMode$.value = mode;
      
      // 3. ä¿å­˜é…ç½®
      await this.storage.saveLayoutConfig(docId, {
        layoutMode: mode,
        columnWidths: this._columnWidths$.value,
        timestamp: Date.now()
      });
      
      // 4. è§¦å‘åˆ‡æ¢åäº‹ä»¶
      this._emitAfterChange(mode);
      
    } finally {
      this._isTransitioning$.value = false;
    }
  }
  
  distributeContent(blocks: Block[]): Block[][] {
    return this.distributor.distributeBlocks(
      blocks, 
      this.columnCount$.value
    );
  }
  
  // === äº‹ä»¶ç³»ç»Ÿ ===
  onLayoutModeChange(): Observable<LayoutModeChangeEvent> {
    return this.layoutModeChange$;
  }
  
  onLayoutError(): Observable<LayoutError> {
    return this.layoutError$;
  }
}
```

### 2. ColumnDistributor (å†…å®¹åˆ†é…å™¨)

```typescript
/**
 * åˆ—å†…å®¹åˆ†é…å™¨ - æ™ºèƒ½å†…å®¹åˆ†é…ç®—æ³•
 * 
 * èŒè´£:
 * - å®ç°å¤šç§åˆ†é…ç­–ç•¥
 * - ä¼˜åŒ–å†…å®¹åœ¨å„åˆ—é—´çš„å¹³è¡¡
 * - å¤„ç†ç‰¹æ®ŠBlockçš„åˆ†é…é€»è¾‘
 * - æ”¯æŒè‡ªå®šä¹‰åˆ†é…è§„åˆ™
 */
export class ColumnDistributor {
  private strategies = new Map<DistributionStrategy, DistributionAlgorithm>();
  
  constructor() {
    this.registerStrategy('round-robin', new RoundRobinDistribution());
    this.registerStrategy('balanced-height', new BalancedHeightDistribution());
    this.registerStrategy('content-aware', new ContentAwareDistribution());
  }
  
  distributeBlocks(
    blocks: Block[], 
    columnCount: number,
    strategy: DistributionStrategy = 'balanced-height'
  ): Block[][] {
    if (columnCount === 1) {
      return [blocks];
    }
    
    const algorithm = this.strategies.get(strategy);
    if (!algorithm) {
      throw new Error(`Unknown distribution strategy: ${strategy}`);
    }
    
    return algorithm.distribute(blocks, columnCount);
  }
  
  redistributeOnModeChange(
    currentColumns: Block[][],
    newColumnCount: number
  ): Block[][] {
    // åˆå¹¶æ‰€æœ‰åˆ—çš„å†…å®¹
    const allBlocks = currentColumns.flat();
    
    // é‡æ–°åˆ†é…
    return this.distributeBlocks(allBlocks, newColumnCount);
  }
}

/**
 * å¹³è¡¡é«˜åº¦åˆ†é…ç®—æ³•
 */
class BalancedHeightDistribution implements DistributionAlgorithm {
  distribute(blocks: Block[], columnCount: number): Block[][] {
    const columns: Block[][] = Array.from({length: columnCount}, () => []);
    const columnHeights: number[] = Array(columnCount).fill(0);
    
    // æŒ‰Blockä¼°ç®—é«˜åº¦æ’åº (å¤§çš„ä¼˜å…ˆ)
    const sortedBlocks = this.sortByEstimatedHeight(blocks);
    
    for (const block of sortedBlocks) {
      // æ‰¾åˆ°å½“å‰é«˜åº¦æœ€å°çš„åˆ—
      const minHeightIndex = this.findMinHeightColumn(columnHeights);
      
      columns[minHeightIndex].push(block);
      columnHeights[minHeightIndex] += this.estimateBlockHeight(block);
    }
    
    return columns;
  }
  
  private estimateBlockHeight(block: Block): number {
    const heightMap: Record<string, number> = {
      'affine:paragraph': this.estimateParagraphHeight(block),
      'affine:image': 250,
      'affine:database': 300,
      'affine:list': this.estimateListHeight(block),
      'affine:callout': 120,
      'affine:code': this.estimateCodeHeight(block),
    };
    
    return heightMap[block.flavour] || 80;
  }
  
  private estimateParagraphHeight(block: Block): number {
    const text = block.text?.toString() || '';
    const lineHeight = 24;
    const charsPerLine = 60;
    const lines = Math.ceil(text.length / charsPerLine);
    return Math.max(lines * lineHeight, 50);
  }
}
```

### 3. LayoutRenderer (å¸ƒå±€æ¸²æŸ“å™¨)

```typescript
/**
 * å¸ƒå±€æ¸²æŸ“å™¨ - è´Ÿè´£UIæ¸²æŸ“é€»è¾‘
 * 
 * èŒè´£:
 * - æ ¹æ®å¸ƒå±€æ¨¡å¼æ¸²æŸ“UIç»“æ„
 * - ç®¡ç†å¸ƒå±€åˆ‡æ¢åŠ¨ç”»
 * - å¤„ç†å“åº”å¼å¸ƒå±€é€‚é…
 * - ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
 */
export class LayoutRenderer {
  private animationManager = new AnimationManager();
  private viewportManager = new ViewportManager();
  
  async renderLayout(
    mode: PageLayoutMode,
    blocks: Block[],
    container: HTMLElement
  ): Promise<void> {
    // 1. å‡†å¤‡æ¸²æŸ“æ•°æ®
    const columnData = this.prepareColumnData(mode, blocks);
    
    // 2. åˆ›å»ºå¸ƒå±€å®¹å™¨
    const layoutContainer = this.createLayoutContainer(mode);
    
    // 3. æ¸²æŸ“å„åˆ—å†…å®¹
    const columnElements = await this.renderColumns(columnData);
    
    // 4. æ‰§è¡Œå¸ƒå±€åˆ‡æ¢åŠ¨ç”»
    await this.animationManager.transitionToLayout(
      container,
      layoutContainer,
      columnElements
    );
    
    // 5. è®¾ç½®å“åº”å¼ç›‘å¬
    this.viewportManager.setupResponsiveListeners(layoutContainer);
  }
  
  private createLayoutContainer(mode: PageLayoutMode): HTMLElement {
    const container = document.createElement('div');
    container.className = `column-layout-container layout-${mode}`;
    
    // è®¾ç½®CSS Gridå±æ€§
    const columnCount = LayoutModeConfig[mode].columns;
    container.style.gridTemplateColumns = `repeat(${columnCount}, 1fr)`;
    
    return container;
  }
  
  private async renderColumns(columnData: ColumnData[]): Promise<HTMLElement[]> {
    const columnElements: HTMLElement[] = [];
    
    for (const [index, data] of columnData.entries()) {
      const columnEl = await this.renderSingleColumn(index, data);
      columnElements.push(columnEl);
    }
    
    return columnElements;
  }
  
  private async renderSingleColumn(
    index: number,
    data: ColumnData
  ): Promise<HTMLElement> {
    const column = document.createElement('div');
    column.className = 'column-content';
    column.setAttribute('data-column-index', index.toString());
    
    // æ¸²æŸ“åˆ—å¤´ (å¯é€‰)
    if (data.showHeader) {
      column.appendChild(this.createColumnHeader(index));
    }
    
    // æ¸²æŸ“Blockå†…å®¹
    const contentContainer = this.createContentContainer();
    for (const block of data.blocks) {
      const blockElement = await this.renderBlock(block);
      contentContainer.appendChild(blockElement);
    }
    column.appendChild(contentContainer);
    
    // æ¸²æŸ“æ·»åŠ æŒ‰é’®
    column.appendChild(this.createAddButton(index));
    
    return column;
  }
}
```

### 4. StorageService (å­˜å‚¨æœåŠ¡)

```typescript
/**
 * å­˜å‚¨æœåŠ¡ - å¸ƒå±€é…ç½®æŒä¹…åŒ–
 * 
 * èŒè´£:
 * - æœ¬åœ°å­˜å‚¨ç®¡ç†
 * - äº‘ç«¯åŒæ­¥ (å¯é€‰)
 * - é…ç½®ç¼“å­˜
 * - æ•°æ®è¿ç§»
 */
export class StorageService {
  private cache = new Map<string, DocLayoutConfig>();
  private syncManager?: CloudSyncManager;
  
  async saveLayoutConfig(docId: string, config: Partial<DocLayoutConfig>): Promise<void> {
    const fullConfig: DocLayoutConfig = {
      docId,
      layoutMode: PageLayoutMode.Normal,
      columnWidths: [1, 1, 1, 1, 1],
      responsive: true,
      lastModified: Date.now(),
      ...config
    };
    
    // æ›´æ–°ç¼“å­˜
    this.cache.set(docId, fullConfig);
    
    // ä¿å­˜åˆ°localStorage
    try {
      localStorage.setItem(
        this.getStorageKey(docId),
        JSON.stringify(fullConfig)
      );
    } catch (error) {
      console.warn('Failed to save layout config to localStorage:', error);
    }
    
    // äº‘ç«¯åŒæ­¥ (å¦‚æœå¯ç”¨)
    if (this.syncManager) {
      await this.syncManager.uploadConfig(fullConfig);
    }
  }
  
  async loadLayoutConfig(docId: string): Promise<DocLayoutConfig | null> {
    // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
    if (this.cache.has(docId)) {
      return this.cache.get(docId)!;
    }
    
    // ä»localStorageåŠ è½½
    try {
      const stored = localStorage.getItem(this.getStorageKey(docId));
      if (stored) {
        const config = JSON.parse(stored) as DocLayoutConfig;
        this.cache.set(docId, config);
        return config;
      }
    } catch (error) {
      console.warn('Failed to load layout config from localStorage:', error);
    }
    
    // äº‘ç«¯åŠ è½½ (å¦‚æœå¯ç”¨)
    if (this.syncManager) {
      const cloudConfig = await this.syncManager.downloadConfig(docId);
      if (cloudConfig) {
        this.cache.set(docId, cloudConfig);
        return cloudConfig;
      }
    }
    
    return null;
  }
  
  async clearLayoutConfig(docId: string): Promise<void> {
    this.cache.delete(docId);
    localStorage.removeItem(this.getStorageKey(docId));
    
    if (this.syncManager) {
      await this.syncManager.deleteConfig(docId);
    }
  }
  
  private getStorageKey(docId: string): string {
    return `blocksuite-layout-${docId}`;
  }
}
```

## ğŸ¨ UIç»„ä»¶æ¶æ„

### 1. LayoutSwitcher (å¸ƒå±€åˆ‡æ¢å™¨)

```typescript
/**
 * å¸ƒå±€åˆ‡æ¢å™¨ - ç”¨æˆ·äº¤äº’çš„ä¸»è¦å…¥å£
 */
@customElement('layout-switcher')
export class LayoutSwitcher extends LitElement {
  @property() docId!: string;
  @property() currentMode: PageLayoutMode = PageLayoutMode.Normal;
  @property() disabled = false;
  
  @state() private isLoading = false;
  
  private layoutService!: PageLayoutService;
  
  static styles = css`
    :host {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--affine-background-secondary-color);
      border-radius: 8px;
      border: 1px solid var(--affine-border-color);
    }
    
    .layout-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 6px;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--affine-icon-color);
    }
    
    .layout-button:hover {
      background: var(--affine-hover-color);
      color: var(--affine-primary-color);
    }
    
    .layout-button.active {
      background: var(--affine-primary-color);
      color: white;
    }
    
    .layout-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  `;
  
  render() {
    return html`
      <div class="layout-switcher-container">
        ${Object.values(PageLayoutMode).map(mode => 
          this.renderModeButton(mode)
        )}
      </div>
    `;
  }
  
  private renderModeButton(mode: PageLayoutMode) {
    const config = LayoutModeConfig[mode];
    const isActive = this.currentMode === mode;
    
    return html`
      <button
        class="layout-button ${isActive ? 'active' : ''}"
        ?disabled=${this.disabled || this.isLoading}
        title=${config.label}
        @click=${() => this.switchToMode(mode)}
      >
        ${this.renderModeIcon(mode)}
      </button>
    `;
  }
  
  private renderModeIcon(mode: PageLayoutMode) {
    const config = LayoutModeConfig[mode];
    return html`<span class="layout-icon">${config.icon}</span>`;
  }
  
  private async switchToMode(mode: PageLayoutMode) {
    if (mode === this.currentMode || this.isLoading) return;
    
    this.isLoading = true;
    
    try {
      await this.layoutService.setLayoutMode(mode, this.docId);
      this.currentMode = mode;
      
      // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶
      this.dispatchEvent(new CustomEvent('layout-mode-changed', {
        detail: { mode, docId: this.docId },
        bubbles: true
      }));
      
    } catch (error) {
      console.error('Failed to switch layout mode:', error);
      
      // æ˜¾ç¤ºé”™è¯¯æç¤º
      this.dispatchEvent(new CustomEvent('layout-error', {
        detail: { error, mode },
        bubbles: true
      }));
      
    } finally {
      this.isLoading = false;
    }
  }
}
```

### 2. ColumnContent (åˆ—å†…å®¹ç»„ä»¶)

```typescript
/**
 * åˆ—å†…å®¹ç»„ä»¶ - å•åˆ—çš„å†…å®¹ç®¡ç†
 */
@customElement('column-content')
export class ColumnContent extends LitElement {
  @property() columnIndex!: number;
  @property() blocks: Block[] = [];
  @property() readonly = false;
  
  @state() private isDragOver = false;
  @state() private isAddingContent = false;
  
  static styles = css`
    :host {
      display: flex;
      flex-direction: column;
      min-height: 200px;
      padding: 16px;
      border-radius: 8px;
      border: 2px dashed var(--affine-border-color);
      transition: all 0.3s ease;
    }
    
    :host(.drag-over) {
      border-color: var(--affine-primary-color);
      background: var(--affine-hover-color);
    }
    
    .column-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--affine-border-color);
    }
    
    .column-title {
      font-size: 14px;
      font-weight: 500;
      color: var(--affine-text-secondary-color);
    }
    
    .block-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .add-content-button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      margin-top: 16px;
      border: 1px dashed var(--affine-border-color);
      border-radius: 6px;
      background: transparent;
      cursor: pointer;
      color: var(--affine-text-secondary-color);
      transition: all 0.2s ease;
    }
    
    .add-content-button:hover {
      border-color: var(--affine-primary-color);
      color: var(--affine-primary-color);
      background: var(--affine-hover-color);
    }
  `;
  
  render() {
    return html`
      <div class="column-header">
        <span class="column-title">ç¬¬ ${this.columnIndex + 1} åˆ—</span>
        <column-actions .columnIndex=${this.columnIndex}></column-actions>
      </div>
      
      <div class="block-container" @drop=${this.onDrop} @dragover=${this.onDragOver}>
        ${this.blocks.map(block => this.renderBlock(block))}
      </div>
      
      ${!this.readonly ? html`
        <button class="add-content-button" @click=${this.openAddMenu}>
          <plus-icon></plus-icon>
          <span>æ·»åŠ å†…å®¹</span>
        </button>
      ` : ''}
    `;
  }
  
  private renderBlock(block: Block) {
    // ä½¿ç”¨BlockSuiteçš„æ ‡å‡†Blockæ¸²æŸ“æœºåˆ¶
    return html`<block-element .block=${block}></block-element>`;
  }
  
  private onDragOver(e: DragEvent) {
    e.preventDefault();
    this.isDragOver = true;
    this.classList.add('drag-over');
  }
  
  private onDrop(e: DragEvent) {
    e.preventDefault();
    this.isDragOver = false;
    this.classList.remove('drag-over');
    
    // å¤„ç†Blockæ‹–æ‹½é€»è¾‘
    const blockData = e.dataTransfer?.getData('application/block');
    if (blockData) {
      this.handleBlockDrop(JSON.parse(blockData));
    }
  }
  
  private async openAddMenu() {
    if (this.readonly) return;
    
    this.isAddingContent = true;
    
    // æ˜¾ç¤ºBlockSuiteçš„slash menu
    const event = new CustomEvent('show-slash-menu', {
      detail: {
        columnIndex: this.columnIndex,
        position: this.getBoundingClientRect()
      },
      bubbles: true
    });
    
    this.dispatchEvent(event);
  }
}
```

## ğŸ­ åŠ¨ç”»ç³»ç»Ÿè®¾è®¡

### 1. AnimationManager (åŠ¨ç”»ç®¡ç†å™¨)

```typescript
/**
 * åŠ¨ç”»ç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†å¸ƒå±€åˆ‡æ¢åŠ¨ç”»
 */
export class AnimationManager {
  private animationQueue: Animation[] = [];
  private isAnimating = false;
  
  async transitionToLayout(
    oldContainer: HTMLElement,
    newContainer: HTMLElement,
    newColumns: HTMLElement[]
  ): Promise<void> {
    if (this.isAnimating) {
      await this.waitForAnimationComplete();
    }
    
    this.isAnimating = true;
    
    try {
      // 1. æ·¡å‡ºæ—§å¸ƒå±€
      await this.fadeOut(oldContainer);
      
      // 2. æ›¿æ¢å®¹å™¨
      oldContainer.parentNode?.replaceChild(newContainer, oldContainer);
      
      // 3. æ·¡å…¥æ–°å¸ƒå±€
      await this.fadeInColumns(newColumns);
      
    } finally {
      this.isAnimating = false;
    }
  }
  
  private async fadeOut(element: HTMLElement): Promise<void> {
    return new Promise(resolve => {
      const animation = element.animate([
        { opacity: 1, transform: 'scale(1)' },
        { opacity: 0, transform: 'scale(0.95)' }
      ], {
        duration: 200,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
      });
      
      animation.onfinish = () => resolve();
      this.animationQueue.push(animation);
    });
  }
  
  private async fadeInColumns(columns: HTMLElement[]): Promise<void> {
    // è®¾ç½®åˆå§‹çŠ¶æ€
    columns.forEach(column => {
      column.style.opacity = '0';
      column.style.transform = 'translateY(20px)';
    });
    
    // ä¾æ¬¡æ·¡å…¥å„åˆ—
    const animations = columns.map((column, index) => {
      return new Promise<void>(resolve => {
        setTimeout(() => {
          const animation = column.animate([
            { opacity: 0, transform: 'translateY(20px)' },
            { opacity: 1, transform: 'translateY(0)' }
          ], {
            duration: 300,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'forwards'
          });
          
          animation.onfinish = () => resolve();
          this.animationQueue.push(animation);
        }, index * 100); // é”™å¼€åŠ¨ç”»æ—¶é—´
      });
    });
    
    await Promise.all(animations);
  }
  
  private async waitForAnimationComplete(): Promise<void> {
    await Promise.all(
      this.animationQueue.map(animation => animation.finished)
    );
    this.animationQueue = [];
  }
}
```

### 2. ResponsiveManager (å“åº”å¼ç®¡ç†å™¨)

```typescript
/**
 * å“åº”å¼ç®¡ç†å™¨ - å¤„ç†ä¸åŒå±å¹•å°ºå¯¸çš„å¸ƒå±€é€‚é…
 */
export class ResponsiveManager {
  private breakpoints = {
    mobile: 768,
    tablet: 1024,
    desktop: 1440
  };
  
  private observers = new Set<ResizeObserver>();
  
  getEffectiveMode(requestedMode: PageLayoutMode): PageLayoutMode {
    const screenWidth = window.innerWidth;
    const maxColumns = this.getMaxColumnsForWidth(screenWidth);
    const requestedColumns = LayoutModeConfig[requestedMode].columns;
    
    if (requestedColumns <= maxColumns) {
      return requestedMode;
    }
    
    // é™çº§åˆ°æ”¯æŒçš„æœ€å¤§åˆ—æ•°
    return this.getModeByColumnCount(maxColumns);
  }
  
  private getMaxColumnsForWidth(width: number): number {
    if (width < this.breakpoints.mobile) return 1;
    if (width < this.breakpoints.tablet) return 2;
    if (width < this.breakpoints.desktop) return 4;
    return 5;
  }
  
  private getModeByColumnCount(columns: number): PageLayoutMode {
    const modeMap = {
      1: PageLayoutMode.Normal,
      2: PageLayoutMode.TwoColumn,
      3: PageLayoutMode.ThreeColumn,
      4: PageLayoutMode.FourColumn,
      5: PageLayoutMode.FiveColumn
    };
    
    return modeMap[columns as keyof typeof modeMap] || PageLayoutMode.Normal;
  }
  
  setupResponsiveListeners(container: HTMLElement): void {
    // ä½¿ç”¨ResizeObserverç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
    const observer = new ResizeObserver(entries => {
      for (const entry of entries) {
        this.handleContainerResize(entry);
      }
    });
    
    observer.observe(container);
    this.observers.add(observer);
  }
  
  private handleContainerResize(entry: ResizeObserverEntry): void {
    const { width } = entry.contentRect;
    const container = entry.target as HTMLElement;
    
    // æ ¹æ®å®¹å™¨å®½åº¦è°ƒæ•´å¸ƒå±€
    this.adjustLayoutForWidth(container, width);
  }
  
  private adjustLayoutForWidth(container: HTMLElement, width: number): void {
    const maxColumns = this.getMaxColumnsForWidth(width);
    const currentColumns = this.getCurrentColumnCount(container);
    
    if (currentColumns > maxColumns) {
      // éœ€è¦å‡å°‘åˆ—æ•°
      this.forceColumnReduction(container, maxColumns);
    }
  }
  
  dispose(): void {
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–æ¶æ„

### 1. VirtualizationManager (è™šæ‹ŸåŒ–ç®¡ç†å™¨)

```typescript
/**
 * è™šæ‹ŸåŒ–ç®¡ç†å™¨ - å¤„ç†å¤§é‡å†…å®¹çš„æ€§èƒ½ä¼˜åŒ–
 */
export class VirtualizationManager {
  private visibleRange = { start: 0, end: 10 };
  private itemHeight = 80; // å¹³å‡Blocké«˜åº¦
  private scrollContainer: HTMLElement | null = null;
  
  setupVirtualization(container: HTMLElement, blocks: Block[]): void {
    if (blocks.length < 50) {
      // å†…å®¹è¾ƒå°‘æ—¶ä¸å¯ç”¨è™šæ‹ŸåŒ–
      return;
    }
    
    this.scrollContainer = container;
    this.setupScrollListener();
    this.calculateVisibleRange();
  }
  
  private setupScrollListener(): void {
    if (!this.scrollContainer) return;
    
    let ticking = false;
    
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          this.calculateVisibleRange();
          ticking = false;
        });
        ticking = true;
      }
    };
    
    this.scrollContainer.addEventListener('scroll', handleScroll, { passive: true });
  }
  
  private calculateVisibleRange(): void {
    if (!this.scrollContainer) return;
    
    const scrollTop = this.scrollContainer.scrollTop;
    const containerHeight = this.scrollContainer.clientHeight;
    
    const start = Math.floor(scrollTop / this.itemHeight);
    const end = Math.ceil((scrollTop + containerHeight) / this.itemHeight);
    
    this.visibleRange = { start, end };
  }
  
  getVisibleBlocks(blocks: Block[]): Block[] {
    return blocks.slice(this.visibleRange.start, this.visibleRange.end);
  }
}
```

### 2. CacheManager (ç¼“å­˜ç®¡ç†å™¨)

```typescript
/**
 * ç¼“å­˜ç®¡ç†å™¨ - ä¼˜åŒ–é‡å¤è®¡ç®—å’Œæ¸²æŸ“
 */
export class CacheManager {
  private layoutCache = new Map<string, CachedLayout>();
  private blockHeightCache = new Map<string, number>();
  private maxCacheSize = 100;
  
  getCachedLayout(key: string): CachedLayout | null {
    const cached = this.layoutCache.get(key);
    
    if (cached && this.isValidCache(cached)) {
      cached.lastAccessed = Date.now();
      return cached;
    }
    
    return null;
  }
  
  setCachedLayout(key: string, layout: CachedLayout): void {
    if (this.layoutCache.size >= this.maxCacheSize) {
      this.evictOldest();
    }
    
    layout.lastAccessed = Date.now();
    this.layoutCache.set(key, layout);
  }
  
  getCachedBlockHeight(blockId: string): number | null {
    return this.blockHeightCache.get(blockId) || null;
  }
  
  setCachedBlockHeight(blockId: string, height: number): void {
    this.blockHeightCache.set(blockId, height);
  }
  
  private isValidCache(cached: CachedLayout): boolean {
    const maxAge = 5 * 60 * 1000; // 5åˆ†é’Ÿ
    return Date.now() - cached.timestamp < maxAge;
  }
  
  private evictOldest(): void {
    let oldestKey = '';
    let oldestTime = Date.now();
    
    for (const [key, value] of this.layoutCache) {
      if (value.lastAccessed < oldestTime) {
        oldestTime = value.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.layoutCache.delete(oldestKey);
    }
  }
  
  clear(): void {
    this.layoutCache.clear();
    this.blockHeightCache.clear();
  }
}
```

## ğŸ”Œ æ‰©å±•æ¥å£è®¾è®¡

### 1. LayoutExtensionAPI

```typescript
/**
 * å¸ƒå±€æ‰©å±•API - å…è®¸ç¬¬ä¸‰æ–¹æ‰©å±•å¸ƒå±€åŠŸèƒ½
 */
export interface LayoutExtensionAPI {
  // æ³¨å†Œè‡ªå®šä¹‰å¸ƒå±€æ¨¡å¼
  registerLayoutMode(mode: CustomLayoutMode): void;
  
  // æ³¨å†Œè‡ªå®šä¹‰åˆ†é…ç­–ç•¥
  registerDistributionStrategy(strategy: DistributionStrategy): void;
  
  // æ³¨å†Œå¸ƒå±€äº‹ä»¶ç›‘å¬å™¨
  onLayoutChange(listener: LayoutChangeListener): void;
  
  // è·å–å½“å‰å¸ƒå±€çŠ¶æ€
  getCurrentLayoutState(): LayoutState;
  
  // å¼ºåˆ¶é‡æ–°è®¡ç®—å¸ƒå±€
  recalculateLayout(): Promise<void>;
}

/**
 * è‡ªå®šä¹‰å¸ƒå±€æ¨¡å¼æ¥å£
 */
export interface CustomLayoutMode {
  id: string;
  name: string;
  icon: string;
  columns: number;
  renderer: CustomLayoutRenderer;
  constraints?: LayoutConstraints;
}

/**
 * å¸ƒå±€çº¦æŸæ¥å£
 */
export interface LayoutConstraints {
  minWidth?: number;
  maxWidth?: number;
  minColumns?: number;
  maxColumns?: number;
  supportedBlockTypes?: string[];
  responsiveBreakpoints?: ResponsiveBreakpoints;
}
```

### 2. æ’ä»¶ç³»ç»Ÿ

```typescript
/**
 * å¸ƒå±€æ’ä»¶åŸºç±»
 */
export abstract class LayoutPlugin {
  abstract id: string;
  abstract name: string;
  abstract version: string;
  
  abstract install(api: LayoutExtensionAPI): void;
  abstract uninstall(): void;
  
  // å¯é€‰çš„ç”Ÿå‘½å‘¨æœŸé’©å­
  onLayoutModeChange?(from: PageLayoutMode, to: PageLayoutMode): void;
  onColumnResize?(columnIndex: number, newWidth: number): void;
  onBlockMove?(blockId: string, fromColumn: number, toColumn: number): void;
}

/**
 * ç¤ºä¾‹æ’ä»¶: ç½‘æ ¼å¸ƒå±€æ’ä»¶
 */
export class GridLayoutPlugin extends LayoutPlugin {
  id = 'grid-layout';
  name = 'Grid Layout';
  version = '1.0.0';
  
  install(api: LayoutExtensionAPI): void {
    // æ³¨å†Œç½‘æ ¼å¸ƒå±€æ¨¡å¼
    api.registerLayoutMode({
      id: 'grid-2x2',
      name: '2x2ç½‘æ ¼',
      icon: 'âš',
      columns: 4,
      renderer: new GridLayoutRenderer()
    });
    
    // ç›‘å¬å¸ƒå±€å˜åŒ–
    api.onLayoutChange((event) => {
      if (event.mode === 'grid-2x2') {
        this.setupGridBehavior();
      }
    });
  }
  
  uninstall(): void {
    // æ¸…ç†èµ„æº
  }
  
  private setupGridBehavior(): void {
    // å®ç°ç½‘æ ¼ç‰¹å®šçš„è¡Œä¸º
  }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-07-27  
**æœ€åæ›´æ–°**: 2025-07-27  
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸  
# 保存与待保存标记（功能 + 实现说明）

> 关联上级：`管理后台/系统设置与模块配置.md`  
> 相关代码位置：
> - 配置数据管理：`packages/frontend/admin/src/modules/settings/use-app-config.ts`
> - 设置页面：`packages/frontend/admin/src/modules/settings/index.tsx`

---

## 1. 更新逻辑：update(path, value)

### 1.1 update 的职责

`useAppConfig` 中的 `update` 用于响应用户在界面上对配置字段的修改：

- 接收形如 `module/field` 或 `module/field/subField` 的路径字符串；
- 计算该字段的原始值 `from` 与新的目标值 `to`；
- 在 `updates` 中记录本次修改；
- 同时更新 `patchedAppConfig`，让 UI 立即反映最新输入。

核心实现（简化版）：

```ts
const update = useCallback(
  (path: string, value: any) => {
    const [module, field, subField] = path.split('/');
    const key = `${module}.${field}`;
    const from = get(appConfig, key);

    setUpdates(prev => {
      const to = subField
        ? set(prev[key]?.to ?? { ...from }, subField, value)
        : value;

      return {
        ...prev,
        [key]: { from, to },
      };
    });

    setPatchedAppConfig(prev => {
      return set(
        prev,
        `${module}.${field}${subField ? `.${subField}` : ''}`,
        value
      );
    });
  },
  [mockAppConfig]
);
```

### 1.2 updates 结构说明

- `updates` 的类型为：

```ts
export type AppConfigUpdates = Record<string, { from: any; to: any }>;
```

- key 为 `module.field`（例如 `auth.allowSignup`、`copilot.enabled`）；
- `from`：保存“页面打开时”的原始值；
- `to`：保存用户在页面上修改后的目标值：
  - 若是简单字段，`to` 即为新的原始值；
  - 若是带有子字段的对象（如 `passwordRequirements.min`），则 `to` 会是一个包含多个子字段的对象。

> 这样的结构使得后续可以方便地：
> - 对比某个字段是否被修改（只需检查 `from !== to`）；
> - 一次性把所有修改以“增量更新”的形式提交给后端。

---

## 2. 待保存计数与模块脏状态

### 2.1 全局待保存计数 pendingCount

在 `SettingsPage` 中，通过 `updates` 直接计算全局待保存项数量：

```ts
const pendingCount = Object.keys(updates).length;
```

- 若 `pendingCount === 0`：
  - 表示当前所有配置都与原始值一致；
  - 顶部“保存更改”按钮会被禁用；
  - 不显示“X 项待保存”的徽标。
- 若 `pendingCount > 0`：
  - 表示有至少一个字段已被修改但未保存；
  - “保存更改”按钮可用；
  - 顶部会显示“X 项待保存”的提示。

### 2.2 按模块统计脏状态 dirtyModules

为了在左侧导航中标记“哪些模块存在未保存修改”，`SettingsPage` 对 `updates` 进行了按模块归类：

```ts
const dirtyModules = useMemo(() => {
  return Object.keys(updates).reduce<Record<string, number>>((acc, key) => {
    const [moduleKey] = key.split('.'); // 例如 'auth.passwordRequirements' → 'auth'
    acc[moduleKey] = (acc[moduleKey] ?? 0) + 1;
    return acc;
  }, {});
}, [updates]);
```

- `dirtyModules` 的结构为：`Record<module, changedFieldCount>`；
- 左侧 `SettingsSidebar` 在渲染模块时，会检查：

```tsx
const isDirty = dirtyModules[group.module];
{isDirty ? (
  <Badge variant="outline" className="text-[10px]">
    待保存
  </Badge>
) : null}
```

- 这样可以让管理员一眼看出：
  - 当前在哪些模块做过修改；
  - 即使切换到其他模块，修改记录仍然保留，直到执行保存操作。

---

## 3. 保存流程：save()

### 3.1 将 updates 转换为后端输入

当用户点击“保存更改”按钮时，`SettingsPage` 会调用 `saveChanges`，内部实际执行的是 `useAppConfig` 提供的 `save()`：

```ts
const saveChanges = useCallback(() => {
  if (Object.keys(updates).length === 0) {
    return;
  }
  save();
}, [save, updates]);
```

在 `useAppConfig` 中，`save` 会将 `updates` 转换为后端期望的 `UpdateAppConfigInput[]`：

```ts
const save = useAsyncCallback(async () => {
  const updateInputs: UpdateAppConfigInput[] = Object.entries(updates).map(
    ([key, value]) => {
      const splitIndex = key.indexOf('.');
      const module = key.slice(0, splitIndex);
      const field = key.slice(splitIndex + 1);

      return {
        module,
        key: field,
        value: value.to,
      };
    }
  );

  try {
    console.log('保存配置更新:', updateInputs);
    await new Promise(resolve => setTimeout(resolve, 500));
    setUpdates({});
    notify.success({ title: '已保存', message: '设置已成功保存。' });
  } catch (e) {
    const error = UserFriendlyError.fromAny(e);
    notify.error({ title: 'Failed to save', message: error.message });
  }
}, [updates]);
```

- 对每一个 `updates` 条目：
  - 从 key 中拆分出 `module` 与 `field`；
  - 将 `value.to` 作为新的配置值；
  - 组装成 `{ module, key, value }` 的结构。
- 在当前实现中：
  - 使用 `console.log` 模拟发送请求；
  - 使用 `notify.success` 提示用户“设置已成功保存”；
  - 清空 `updates`，重置待保存状态。

> 在接入真实后端时，只需将 `console.log` 部分替换为真正的 `useMutation` 调用（`updateAppConfigMutation`），并将返回结果合并到全局 `appConfig` 中即可。

### 3.2 保存成功与失败时的行为

- 保存成功：
  - `updates` 被清空 → `pendingCount` 变为 0；
  - 顶部“待保存”徽标消失；
  - 左侧导航上的“待保存”标记也会自动消失；
  - `patchedAppConfig` 保持最新值，作为新的“原始状态”。
- 保存失败：
  - `updates` 保留（不会丢失用户输入）；
  - 通过 `notify.error` 提示错误信息；
  - 控制台打印详细错误，便于开发/运维排查。

---

## 4. 用户界面反馈与交互细节

### 4.1 顶部 Header 中的待保存提示

在 `SettingsPage` 的 `Header` 右侧，使用 `pendingCount` 控制待保存提示与保存按钮：

- 当 `pendingCount > 0`：
  - 显示一个 `Badge`，内容为“X 项待保存”；
  - “保存更改”按钮可点击。
- 当 `pendingCount === 0`：
  - 不显示 `Badge`；
  - “保存更改”按钮禁用，防止误触或多余请求。

### 4.2 模块级“待保存”徽标

左侧 `SettingsSidebar` 中：

- 当某个模块存在未保存修改时，会在模块名称右侧展示一个小的“待保存”徽标；
- 这有助于管理员：
  - 在跨模块配置时，不忘记哪些模块有修改；
  - 在确认保存前逐一检查相关模块配置是否正确。

> 通过“字段级更新记录 + 模块级脏标记 + 全局待保存计数”的组合，系统设置页面可以在复杂配置场景下仍保持极高的可见性和安全性：用户不会轻易丢失修改，也能清晰知道何时需要保存。 


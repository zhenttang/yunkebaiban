# 系统设置与模块配置（功能 + 实现说明）

> 关联上级：`文档/功能文档/admin.md`  
> 主要代码位置：
> - 设置入口页面：`packages/frontend/admin/src/modules/settings/index.tsx`
> - 配置分组与字段描述：`packages/frontend/admin/src/modules/settings/config.ts`
> - 配置数据加载与保存：`packages/frontend/admin/src/modules/settings/use-app-config.ts`

---

## 1. 设置页面结构与路由（/admin/settings）

### 1.1 路由与入口

- 管理后台中，系统设置入口为：
  - `/admin/settings`：设置首页；
  - `/admin/settings/:module`：具体模块设置页（例如 `/admin/settings/server`、`/admin/settings/storages`）。
- 路由对应组件为 `SettingsPage`（`index.tsx`）：
  - 通过 `useParams<{ module?: string }>()` 读取当前 URL 中的 `module`；
  - 若未指定 `module`，自动跳转到第一个可用模块：

```tsx
useEffect(() => {
  if (module) {
    setCurrentModule(module);
  } else if (ALL_SETTING_GROUPS.length > 0) {
    navigate(`/admin/settings/${ALL_SETTING_GROUPS[0].module}`, { replace: true });
  }
}, [module, setCurrentModule, navigate]);
```

- 这里的 `ALL_SETTING_GROUPS` 来自 `config.ts`，代表所有可配置的模块（见第 2 章）。

### 1.2 页面布局组成

- 默认布局由三部分构成：
  - 左侧 `SettingsSidebar`：配置模块导航；
  - 顶部 `Header`：展示当前模块名称、说明以及“待保存”状态；
  - 右侧主区域 `AdminPanel`：渲染具体配置字段与快捷操作。

```tsx
return (
  <div className="flex h-screen overflow-hidden bg-slate-50/40">
    <SettingsSidebar
      currentModule={module ?? currentModule}
      onNavigate={handleNavigateModule}
      dirtyModules={dirtyModules}
    />
    <div className="flex flex-1 flex-col">
      <Header
        title={currentGroup?.name ?? '设置'}
        subtitle={currentGroup ? `模块：${currentGroup.module}` : undefined}
        endFix={/* 待保存数量 + 保存按钮 */}
      />
      <div className="flex-1 overflow-hidden">
        <AdminPanel
          onUpdate={update}
          appConfig={appConfig}
          patchedAppConfig={patchedAppConfig}
        />
      </div>
    </div>
  </div>
);
```

- 部分模块（如 `server`、`security`、`auth` 等）使用独立的专用页面布局：
  - 当 `module === 'server'` 等特定值时，直接返回对应子页面组件；
  - 这些子页面负责更复杂的可视化或分步配置，但依然复用统一的配置数据结构。

### 1.3 导航与当前模块状态

- `SettingsPage` 通过 `useNav()` 上下文维护当前选中的模块：
  - `currentModule`：当前激活的模块 key（如 `'server'`、`'storages'`）；
  - `setCurrentModule`：在路由变化或用户点击导航时更新。
- 点击左侧导航条目时：
  - 调用 `handleNavigateModule(target)`：
    - 更新路由为 `/admin/settings/${target}`；
    - 同步更新 `currentModule`；
  - 由此保证 URL、导航高亮和主面板展示保持一致。

---

## 2. 配置模块分组与来源

系统设置页面的核心是“模块化配置分组”。前端通过 `config.ts` 中的配置，将后端的配置描述（`config.json`）映射为可视化的配置模块。

### 2.1 已知配置模块（KNOWN_CONFIG_GROUPS）

- `KNOWN_CONFIG_GROUPS` 显式列出了系统内常用的配置模块，每个模块包含：
  - `name`：左侧导航中展示的中文名称（如“服务器”、“认证授权”、“存储服务”等）；
  - `module`：模块标识（如 `'server'`、`'auth'`、`'storages'` 等），同时也是 URL 中的 `:module`；
  - `fields`：该模块中需要展示的配置字段列表；
  - `operations`：该模块的快捷操作组件列表（可选，如“发送测试邮件”、“检测存储配置”等）。

示例（精简版）：

```ts
export const KNOWN_CONFIG_GROUPS = [
  {
    name: '服务器',
    module: 'server',
    fields: ['externalUrl', 'name'],
  },
  {
    name: '认证授权',
    module: 'auth',
    fields: [
      'allowSignup',
      { key: 'passwordRequirements', sub: 'min', type: 'Number', desc: '密码最小长度要求' },
      { key: 'passwordRequirements', sub: 'max', type: 'Number', desc: '密码最大长度要求' },
    ],
  },
  {
    name: '通知服务',
    module: 'mailer',
    fields: ['SMTP.host', 'SMTP.port', 'SMTP.username', 'SMTP.password', 'SMTP.ignoreTLS', 'SMTP.sender'],
    operations: [SendTestEmail],
  },
  // ...
];
```

- 典型模块与职责示例：
  - `server`（服务器）：
    - 站点外部访问地址 `externalUrl`；
    - 展示名称 `name` 以及其他基础信息（通过专用页面管理）。
  - `auth`（认证授权）：
    - 是否允许自助注册 `allowSignup`；
    - 密码长度要求 `passwordRequirements.min/max`；
    - 其他如会话 TTL/TTR 等（在模拟配置中存在）。
  - `mailer`（通知服务）：
    - SMTP 服务器地址、端口、账号密码、发件人、是否忽略 TLS；
    - 附带“发送测试邮件”操作组件。
  - `storages`（存储服务）：
    - 用户上传文件和头像的存储提供商（本地/云）、桶名、附加配置；
    - 附带“检查/初始化存储配置”等快捷操作组件。
  - `oauth`（第三方登录）：
    - Google/Github/OIDC 等 provider 的配置。
  - `copilot`（人工智能）：
    - AI 功能开关、不同供应商的配置、AI 文件存储配置等。
  - `job` / `throttle` / `doc` / `websocket` 等：
    - 任务队列、访问限流、文档历史、WebSocket 相关配置。

### 2.2 动态配置模块（UNKNOWN_CONFIG_GROUPS）

- 除了已知模块之外，前端还会根据后端的 `config.json` 自动生成“未知模块”：

```ts
const ALL_CONFIGURABLE_MODULES = Object.keys(CONFIG_DESCRIPTORS).filter(
  key => !IGNORED_MODULES.includes(key as keyof AppConfig)
);

export const UNKNOWN_CONFIG_GROUPS = ALL_CONFIGURABLE_MODULES
  .filter(module => !KNOWN_CONFIG_GROUPS.some(group => group.module === module))
  .map(module => {
    let name = upperFirst(module);
    if (module === 'metrics') name = '监控指标';
    else if (module === 'crypto') name = '加密服务';
    // ...
    return {
      name,
      module,
      fields: Object.keys(CONFIG_DESCRIPTORS[module]),
      operations: undefined,
    };
  });
```

- 行为说明：
  - 首先枚举 `config.json` 中所有配置模块；
  - 排除掉已被 `KNOWN_CONFIG_GROUPS` 显式处理的模块；
  - 对剩余模块通过简单映射生成中文名称（如 `metrics` → “监控指标”）；
  - 默认将该模块下所有字段作为可配置字段。

- 这样可以保证：
  - 即使后端新增了配置模块，只要在 `config.json` 中添加描述，前端也能自动显示一个基础的配置界面；
  - 对于重要模块，可以随时从 UNKNOWN 提升到 KNOWN，以提供更丰富的字段说明与快捷操作。

### 2.3 ALL_SETTING_GROUPS 与导航

- 最终，所有设置模块组合成 `ALL_SETTING_GROUPS`：

```ts
export const ALL_SETTING_GROUPS = [
  ...KNOWN_CONFIG_GROUPS,
  ...UNKNOWN_CONFIG_GROUPS,
];
```

- `SettingsSidebar` 会遍历 `ALL_SETTING_GROUPS` 生成左侧导航条目；
- 每个条目展示：
  - 模块中文名称 `group.name`；
  - 模块路径 `/group.module`（用于提示实际配置路径）；  
  - 若该模块存在未保存的更改，会额外显示“待保存”徽标（见子文档《设置模块导航视图》）。

---

## 3. 配置数据加载、编辑与保存（总览）

> 详细过程拆分到子文档：
> - 《配置渲染与保存流程/配置字段渲染流程.md》
> - 《配置渲染与保存流程/保存与待保存标记.md》

### 3.1 配置数据结构与来源

- 配置数据类型定义在 `config.ts` 中：

```ts
export type AppConfig = Record<string, Record<string, any>>;
```

- 实际数据加载由 `useAppConfig` 完成（当前实现中使用模拟数据 `mockAppConfig`）：
  - `appConfig`：当前生效的配置快照；
  - `patchedAppConfig`：在当前页面上根据用户输入“临时打补丁”后的配置；
  - `updates`：记录每一个被修改的字段的“前后值”：

```ts
export type AppConfigUpdates = Record<string, { from: any; to: any }>;
```

- 当前实现中，`useAppConfig` 将 `mockAppConfig` 作为初始值，并预填常见模块的默认配置（服务器 URL、认证策略、存储配置等），以便前端界面在没有真实后端 API 时也能正常工作。

### 3.2 配置编辑流程（高层）

- 在 `AdminPanel` 中，每一个配置字段最终都会渲染为一个 `ConfigRow` 组件：
  - 根据字段类型（String / Number / Boolean / Enum / JSON）选择不同的输入控件；
  - 每次用户修改某个字段时，调用 `onChange(path, value)`：
    - `path` 形如 `module/field` 或 `module/field/subField`；
    - 由 `useAppConfig.update(path, value)` 统一接管。

- `update` 内部会：
  - 读取原始值 `from = get(appConfig, key)`；
  - 在 `updates` 中记录新的目标值 `to`；
  - 同时对 `patchedAppConfig` 做一份“就地更新”，以便 UI 可以立即反映最新输入。

> 具体逻辑详见子文档《配置渲染与保存流程/保存与待保存标记.md》。

### 3.3 保存操作与待保存提示

- `SettingsPage` 通过 `updates` 计算整体待保存数量与每个模块的待保存状态：
  - `pendingCount = Object.keys(updates).length`；
  - `dirtyModules`：按模块名归类统计每个模块中被修改的字段数量。
- 顶部 `Header` 右侧：
  - 显示“X 项待保存”的徽标（当 `pendingCount > 0` 时）；
  - “保存更改”按钮在没有修改时禁用（防止空操作）。

- 点击“保存更改”按钮时，会调用 `save()`：
  - 将 `updates` 转换为后端所需的 `UpdateAppConfigInput[]`；
  - 在当前实现中，模拟发送请求并通过 `notify.success` 给出“设置已成功保存”的提示；
  - 保存成功后清空 `updates`，待保存状态归零。

> 这一套机制保证了：管理员在同一页面上可以跨多个模块修改配置，看到明确的“待保存”标记，并在一次提交中统一保存配置变更。后续如果接入真实 REST/GraphQL API，仅需在 `useAppConfig` 中替换相应的查询与提交逻辑即可。


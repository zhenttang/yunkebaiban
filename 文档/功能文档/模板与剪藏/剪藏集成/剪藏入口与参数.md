# 剪藏入口与参数（功能 + 实现说明）

> 关联上级：`模板与剪藏/剪藏集成.md`  
> 相关代码位置：
> - 路由：`packages/frontend/core/src/desktop/router.tsx`（`/clipper/import`）
> - 页面组件：`packages/frontend/core/src/desktop/pages/import-clipper/index.tsx`
> - 剪藏服务定义：`packages/frontend/core/src/modules/import-clipper/services/import.ts`

---

## 1. 剪藏入口 `/clipper/import`

### 1.1 入口说明

- `/clipper/import` 是所有 Web Clipper 剪藏的统一落地入口：
  - 由浏览器扩展在用户剪藏后打开；
  - 不直接依赖现有 workspace/page 路由；
  - 依靠消息机制（`postMessage`）接收剪藏数据。

### 1.2 与扩展的交互方式

- 剪藏扩展以如下方式与页面进行通信：
  - 打开 Yunke 页面（通常是新窗口或新标签）：`window.open('<yunke-url>/clipper/import', ...)`；
  - 在页面加载完成后，向该页面发送消息：

```ts
// 扩展侧伪代码
window.postMessage(
  {
    type: 'yunke-clipper:import',
    payload: clipperInput, // 结构见 ClipperInput
  },
  origin
);
```

- 可选：使用 `MessageChannel` 传递 `MessagePort` 供后续双向通信：

```ts
const channel = new MessageChannel();
targetWindow.postMessage(
  { type: 'yunke-clipper:import', payload: clipperInput },
  origin,
  [channel.port2]
);
// 保留 port1 用于等待 Yunke 返回导入结果
```

---

## 2. 剪藏数据结构 ClipperInput

### 2.1 接口定义

- 在剪藏导入服务 `ImportClipperService` 中定义：

```ts
export interface ClipperInput {
  title: string;
  contentMarkdown: string;
  contentHtml: string;
  attachments: Record<string, Blob>;
  workspace?: 'select-by-user' | 'last-open-workspace';
}
```

- 字段说明：
  - `title`：
    - 剪藏文档的标题；
    - 导入后会作为 Yunke 文档标题写入。
  - `contentMarkdown`：
    - 剪藏后的正文内容，采用 Markdown 格式；
    - 由 `MarkdownTransformer.importMarkdownToDoc` 用于创建 BlockSuite 文档。
  - `contentHtml`：
    - 剪藏内容的 HTML 版本；
    - 当前实现未直接使用，预留给更高保真导入或富文本解析。
  - `attachments`：
    - 剪藏过程中下载的附件（如图片、PDF 等），以 Blob 形式存储；
    - key 为资源标识（通常是 URL 或文件名），value 为对应二进制内容；
    - 当前实现聚焦文本内容，附件支持可在后续版本中扩展。
  - `workspace`：
    - 工作空间选择策略：
      - `'select-by-user'`：导入页面由用户自行选择工作空间；
      - `'last-open-workspace'`：若存在“上一次导入的工作空间”，则尝试自动导入到该空间。

### 2.2 页面侧状态持有

- `/clipper/import` 页面先将剪藏输入存入全局 `LiveData`，再在组件内部取快照：

```ts
const clipperInput$ = new LiveData<ClipperInput | null>(null);

window.addEventListener('message', event => {
  if (
    typeof event.data === 'object' &&
    event.data !== null &&
    event.data.type === 'yunke-clipper:import'
  ) {
    clipperInput$.value = event.data.payload;
    // 省略 MessagePort 处理...
  }
});

// 组件内
const clipperInput = useLiveData(clipperInput$);
const [clipperInputSnapshot, setClipperInputSnapshot] =
  useState<ClipperInput | null>(null);
const isMissingInput = !clipperInputSnapshot;
```

- 使用快照 `clipperInputSnapshot` 的好处：
  - 避免消息流在导入过程中被覆盖；
  - 确保导入逻辑基于一组稳定的剪藏数据。

---

## 3. 安全性与来源校验（当前实现）

### 3.1 消息类型校验

- 页面端对消息做了基础的类型检查：

```ts
if (
  typeof event.data === 'object' &&
  event.data !== null &&
  event.data.type === 'yunke-clipper:import'
) {
  // 认为是合法剪藏消息
}
```

- 当前实现中的额外 `console.log` 输出主要用于本地调试，帮助开发者确认：
  - `event.origin`、`event.source` 是否符合预期；
  - `event.data` 的实际结构；
  - `event.ports` 数量与类型。

### 3.2 登录状态与授权（预期行为）

- 在完整的生产部署中，建议：
  - 仅在用户已登录且具备创建文档权限时允许剪藏导入；
  - 若未登录，展示登录引导并在登录完成后继续导入流程；
  - 可考虑限制允许的 `event.origin`，防止第三方站点伪造剪藏数据。

- 当前代码中与登录相关的一部分逻辑已被注释，以方便本地调试；具体行为记录在子文档《剪藏内容解析与落地策略.md》中。

> 总体上，`/clipper/import` 更关注剪藏数据结构与导入流程本身，安全性与权限控制可以根据部署环境和浏览器扩展的实现进一步加固。 


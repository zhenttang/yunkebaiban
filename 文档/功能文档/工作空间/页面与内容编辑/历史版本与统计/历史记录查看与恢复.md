# 历史记录查看与恢复（功能 + 实现说明）

> 关联上级：`工作空间/页面与内容编辑/历史版本与统计.md`  
> 主要代码位置：
> - 历史记录弹窗：`packages/frontend/core/src/components/yunke/page-history-modal/history-modal.tsx`
> - 历史数据 hooks：`packages/frontend/core/src/components/yunke/page-history-modal/data.ts`
> - 历史弹窗入口：`GlobalPageHistoryModal`（全局挂载）

---

## 1. 历史记录入口与整体交互

### 1.1 功能说明

- 每个页面支持查看最近一段时间内的版本历史；
- 用户可以：
  - 打开“版本历史”弹窗；
  - 在左侧列表中浏览各个历史版本（按时间分组）；
  - 在右侧预览区查看某个版本的内容；
  - 选择一个历史版本并执行“恢复到当前页面”的操作。

### 1.2 弹窗入口与全局挂载

- 全局历史弹窗组件：`GlobalPageHistoryModal`：

```tsx
export const GlobalPageHistoryModal = () => {
  const [{ open, pageId }, setState] = useAtom(pageHistoryModalAtom);
  const workspace = useService(WorkspaceService).workspace;
  const handleOpenChange = useCallback(
    (open: boolean) => {
      track.$.docHistory.$[open ? 'open' : 'close']();
      setState(prev => ({ ...prev, open }));
    },
    [setState]
  );

  return (
    <PageHistoryModal
      open={open}
      onOpenChange={handleOpenChange}
      pageId={pageId}
      docCollection={workspace.docCollection}
    />
  );
};
```

- 说明：
  - 通过 `pageHistoryModalAtom`（Jotai atom）保存当前是否打开、针对哪个 `pageId`；
  - `WorkspaceService.workspace.docCollection` 提供文档集合，用于加载历史快照；
  - 其他地方（例如页面菜单中的“版本历史”按钮）只需要设置 atom，即可打开弹窗。

---

## 2. 历史记录列表（左侧）

### 2.1 数据来源

- 历史列表通过 hook `useDocSnapshotList(workspaceId, pageDocId)` 获取：

```tsx
const [historyList, loadMore, loadingMore] = useDocSnapshotList(
  workspaceId,
  pageDocId
);
```

- `historyList` 的每一项典型包含：
  - `timestamp`：版本时间戳；
  - `editor`：编辑者信息（头像 URL、名称等）；
  - 其他与快照关联的元信息。

### 2.2 分组与折叠展示

- 列表组件 `PageHistoryList` 中，使用 `historyListGroupByDay` 按日期分组：

```tsx
const historyListByDay = useMemo(() => {
  return historyListGroupByDay(historyList);
}, [historyList]);
```

- 每一天作为一个分组：
  - 分组头部显示日期；
  - 可折叠/展开该日期下的历史记录；
  - 使用 `@radix-ui/react-collapsible` 控制折叠状态。

### 2.3 列表项内容

- 列表项展示的信息：
  - 时间（精确到分钟，使用 `i18nTime` 格式化）；
  - 编辑者头像和名称（使用 `Avatar` 组件）；
  - 当前选中版本加上 “current” 标记。

示例代码片段：

```tsx
<div
  className={styles.historyItem}
  data-testid="version-history-item"
  onClick={e => {
    e.stopPropagation();
    onVersionChange(history.timestamp);
  }}
  data-active={activeVersion === history.timestamp}
>
  <span className={styles.historyItemTimestamp}>
    {i18nTime(history.timestamp, {
      absolute: { noDate: true, accuracy: 'minute' },
    })}
    {activeVersion === history.timestamp ? (
      <>
        <span>·</span>
        <div className={styles.historyItemCurrent}>{t['current']()}</div>
      </>
    ) : null}
  </span>
  <div className={styles.historyItemNameWrapper}>
    <Avatar
      className={styles.historyItemAvatar}
      url={history.editor?.avatarUrl ?? ''}
      name={history.editor?.name ?? ''}
      size={22}
    />
    <span className={styles.historyItemName}>
      {history.editor?.name ?? t['unnamed']()}
    </span>
  </div>
</div>
```

### 2.4 加载更多

- 在某一天最后一条记录后，如果 `onLoadMore` 可用，就显示“加载更多”按钮：

```tsx
{isLastGroup && isLastItem && onLoadMore ? (
  <Button
    variant="plain"
    loading={loadingMore}
    disabled={loadingMore}
    onClick={onLoadMore}
  >
    {t['com.yunke.history.confirm-restore-modal.load-more']()}
  </Button>
) : null}
```

- 点击后加载更多历史记录，实现“按需加载”。

---

## 3. 历史版本预览（右侧）

### 3.1 预览组件结构

- 预览由 `HistoryEditorPreview` 负责：

```tsx
const HistoryEditorPreview = ({
  ts,
  historyList,
  snapshotPage,
  onModeChange,
  mode,
  title,
}: HistoryEditorPreviewProps) => {
  // ...
  return (
    <div className={styles.previewWrapper}>
      {/* 根据 activeVersion 渲染对应快照 */}
    </div>
  );
};
```

- 顶部显示：
  - 模式切换：`PureEditorModeSwitch`；
  - 标题：当前页面标题（通过 `DocDisplayMetaService.title$`）；
  - 时间：当前版本的时间戳格式化显示。

### 3.2 快照内容渲染

- 预览内容主要通过只读的 `BlockSuiteEditor` 渲染：

```tsx
{snapshotPage ? (
  <YunkeErrorBoundary>
    <Scrollable.Root className={styles.editorScrollable}>
      <Scrollable.Viewport className={styles.editorScrollableViewport}>
        <BlockSuiteEditor
          className={styles.editor}
          mode={mode}
          page={snapshotPage}
          readonly={true}
        />
      </Scrollable.Viewport>
      <Scrollable.Scrollbar />
    </Scrollable.Root>
  </YunkeErrorBoundary>
) : (
  <div className={styles.loadingContainer}>
    <Loading size={24} />
  </div>
)}
```

- 特点：
  - 与真实编辑器完全一致的渲染效果；
  - 但强制 `readonly={true}`，防止用户在历史预览中进行编辑；
  - 支持在预览中切换模式（文档/白板）查看同一历史版本的不同视图。

### 3.3 模式切换与埋点

- 预览中的模式切换会记录埋点：

```tsx
const onModeChangeWithTrack = useCallback(
  (mode: DocMode) => {
    track.$.docHistory.$.switchPageMode({ mode });
    onModeChange(mode);
  },
  [onModeChange]
);
```

---

## 4. 恢复版本的流程与权限控制

### 4.1 恢复前确认弹窗

- 当用户点击“恢复当前版本”按钮时，调用 `onConfirmRestore`：

```tsx
const onConfirmRestore = useCallback(() => {
  openConfirmModal({
    title: t['com.yunke.history.restore-current-version'](),
    description: t['com.yunke.history.confirm-restore-modal.hint'](),
    // ...
    onConfirm: handleRestore,
  });
}, [handleRestore, openConfirmModal, t]);
```

- 弹窗内容包含：
  - 恢复提示说明；
  - 取消/确定按钮；
  - 测试用 `data-testid`。

### 4.2 恢复逻辑

- 真正的恢复由 `useRestorePage` hook 和 `handleRestore` 完成（逻辑位于 `data.ts`，这里从概念说明）：
  - 将选中历史版本的快照应用到当前文档；
  - 一般会通过 `yjs` 的 `encodeStateAsUpdate` 等机制合并状态：

```ts
import { encodeStateAsUpdate } from 'yjs';
```

（具体细节在 `data.ts` 中实现，这里仅说明使用了 Yjs 的状态更新机制。）

- 恢复成功后：
  - 当前页面内容被替换为选择的历史版本；
  - 模态框自动关闭。

### 4.3 权限控制

- 通过 `useGuard('Doc_Update', pageDocId)` 判断用户是否有恢复权限：

```tsx
const canEdit = useGuard('Doc_Update', pageDocId);

<Button
  variant="primary"
  onClick={onConfirmRestore}
  disabled={isMutating || !activeVersion || !canEdit}
>
  {t['com.yunke.history.restore-current-version']()}
</Button>
```

- 无编辑权限时：
  - 恢复按钮禁用；
  - 用户仍可查看历史版本，但不能执行恢复操作。

### 4.4 套餐限制与提示

- `PlanPrompt` 组件会根据 `WorkspaceQuotaService` 决定版本历史可访问时间范围：
  - Free 工作空间：例如仅支持最近 7 天历史（文本里有对应提示）；
  - Pro 工作空间：例如支持 30 天历史；
  - Workspace owner 会看到“升级”按钮，可以跳转到套餐设置页。

---

## 5. 历史记录相关 UX 细节

- 弹窗尺寸：
  - 宽度为 `calc(100% - 64px)`，高度 80%，居中显示；
  - 禁止点击外部区域关闭（需要点击“返回页面”或关闭按钮）。
- 空历史提示：
  - 当 `activeVersion` 为空时，显示 `EmptyHistoryPrompt`；
  - 提示用户文档还没有历史版本。
- 性能优化：
  - 使用 `Suspense` 与 `EditorLoading` 作为加载状态；
  - 历史列表支持按需加载与按天折叠，避免一次性渲染所有记录。

> 总体上，版本历史模块提供了接近“时间机器”的体验：在不离开当前工作空间/页面的前提下，用户可以安全地浏览历史版本，并在需要时一键恢复，同时兼顾权限和套餐限制。 

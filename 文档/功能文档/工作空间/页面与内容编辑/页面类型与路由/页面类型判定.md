# 页面类型判定（功能 + 实现说明）

> 关联上级：`工作空间/页面与内容编辑/页面类型与路由.md`  
> 主要代码位置：
> - 页面头部：`packages/frontend/core/src/desktop/pages/workspace/detail-page/detail-page-header.tsx`
> - 编辑器模式：`EditorService`、`EditorModeSwitch`
> - 文档元数据：`DocDisplayMetaService`、Store `page.meta`

---

## 1. 页面类型的概念与用途

### 1.1 为什么需要“页面类型”

在工作空间中，一个 `pageId` 对应的页面可以有不同形态：

- 普通文档（page）：以文档编辑为主；
- 白板（edgeless/board 等）：以画布编辑为主；
- 数据库视图页面：以数据表/看板等视图为主；
- 日志/日记页面（journal）：按日期组织的特殊文档；
- 模板页：用作模板而非普通内容页。

前端需要知道当前页面“是什么类型”，以便：

- 在头部显示对应的图标（文档/白板/数据库等）；
- 切换编辑器模式（文档模式 vs 白板模式）；
- 使用不同的布局与工具条；
- 在列表中使用不同的样式或过滤逻辑。

### 1.2 类型判定来源概览

- 首选来源：编辑器当前模式（`editor.mode$`）；
- 元数据来源：`page.meta` 中可能包含类型字段；
- Block 结构回退：通过页面根块或首个块推断（文档/白板/数据库）；
- 模板相关：通过模板服务判断页面是否为模板。

---

## 2. 编辑器模式：`editor.mode$`

### 2.1 使用示例

在普通页面头部 `NormalPageHeader` 中，有如下逻辑：

```tsx
const editor = useService(EditorService).editor;
const currentMode = useLiveData(editor.mode$);

return (
  <Header className={styles.header} ref={containerRef}>
    <ViewTitle title={title} />
    <ViewIcon icon={currentMode ?? 'page'} />
    <EditorModeSwitch />
    {/* ... */}
  </Header>
);
```

- `editor.mode$` 是一个响应式流，表示当前编辑器“模式”：
  - 典型值示例（具体枚举在实现中）：`'page'`、`'edgeless'` 等；
  - 前端通过 `ViewIcon` 使用 `currentMode` 选择不同的图标。

### 2.2 EditorModeSwitch

- `EditorModeSwitch` 组件允许用户在不同模式间切换：
  - 比如在文档模式和白板模式之间切换；
  - 切换后会更新 `editor.mode$`，从而更新头部图标和编辑器行为。

### 2.3 与页面类型的关系

- 在大多数场景下，页面“类型”的最终表现由 `editor.mode$` 决定：
  - 对用户而言，“这个页面是文档还是白板”取决于当前模式；
  - 同一个 `pageId` 在不同模式下视图会不同（如文档内容 + 白板视图）。

---

## 3. 元数据与模板状态：`page.meta` 与模板服务

### 3.1 模板标记

- 在 `detail-page-header.tsx` 中有 `TemplateMark` 组件：

```tsx
const templateDocService = useService(TemplateDocService);
const isTemplate = useLiveData(templateDocService.list.isTemplate$(doc.id));

if (!isTemplate) return null;
```

- 说明：
  - 通过 `TemplateDocService` 判断当前页面是否为“模板页面”；
  - 如果是，则在头部显示一个“Template”标记；
  - 这是一种“页面类型”的补充（模板 vs 普通内容）。

### 3.2 `page.meta` 中的类型信息（概念）

- 虽然在当前片段中没有直接看到 `page.meta.type` 的使用，但在 Store 模型中：
  - 通常会在 `meta` 中保存一些轻量类型信息；
  - 例如用于标识某些特殊页面（如 journal、template、database root 等）。
- 前端依赖：
  - 服务（如 `DocDisplayMetaService`）统一读取这些元信息；
  - 单个组件避免直接操作底层文档结构。

---

## 4. 基于 Block 结构的回退判定（概念层面）

> 这一部分在当前代码中没有直接展开，但对理解页面类型很重要，适合在设计文档中记录为“约定”。

### 4.1 回退策略的必要性

- 某些旧页面或特殊场景可能缺少明确的 `type` 字段；
- 或者在编辑器引擎中，页面类型更依赖“根 Block 类型”；
- 因此需要在服务层定义回退策略：
  - 如：如果根 Block 是“surface/board”，则视为白板页面；
  - 如果根 Block 包含数据库视图，则展示为数据库页面。

### 4.2 常见的 Block 形态与类型映射（示例）

- 根 Block 为 `page` / `doc`：
  - 默认视为普通文档页面；
  - `editor.mode$` 默认为 `'page'`。
- 根 Block 为 `surface` / `edgeless`：
  - 视为白板页面；
  - `editor.mode$` 可能默认为 `'edgeless'`。
- 包含数据库视图 Block：
  - 在文档内部展示数据库视图；
  - 但整体页面仍以文档为主。

> 实际实现中，这部分通常封装在 BlockSuite 集成层与 Store 模型中，前端组件只依赖统一的 `editor.mode$` 与元信息服务。

---

## 5. 常见页面类型一览

从最终用户视角和当前前端逻辑来看，可以归纳出以下几类页面类型（部分由模式/元数据/路径共同决定）：

1. **普通文档页面**
   - 访问路径：`/workspace/:workspaceId/:pageId`
   - `editor.mode$ = 'page'`
   - 头部图标：文档图标。

2. **白板页面**
   - 访问路径同上；
   - `editor.mode$ = 'edgeless'` 或类似值；
   - 头部图标：白板/画布图标；
   - 内容以画布为主。

3. **数据库/视图页面**
   - 访问路径同上（或通过集合/数据库入口进入）；
   - 页面内以数据库视图块为主；
   - 类型可能由元数据或 Block 结构决定。

4. **模板页面**
   - 可通过模板中心或模板导入界面访问；
   - `TemplateMark` 显示页面是“模板”；
   - 通常作为复制来源，而非直接编辑的工作内容。

5. **日志/特殊页面**
   - 如 `JournalPageHeader` 使用专门的头部组件；
   - 标题可能由日期等规则生成；
   - 使用特定图标（例如 `icon="journal"`）。

---

## 6. 与路由层的结合

- 路由负责决定“进入哪个页面”（根据 `workspaceId` 与 `pageId`）：
  - 由 `workbenchRoutes` 和 `detail-page` 组件处理。
- 页面类型判定负责决定“这个页面以什么形态呈现”：
  - 通过 `editor.mode$`、模板服务、元数据等；
  - 与 BlockSuite 编辑器及上层 UI（头部、图标、工具栏）联动。

> 这两层职责明确分工：路由选择页面，类型判定选择展示方式。这样既利于扩展新类型（如未来添加“看板模式”等），也利于保持路由结构的稳定。 


<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Limitless | The OS for Thinking</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=JetBrains+Mono:wght@400&family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <style>
        :root {
            --bg-color: #F3F4F6;
            --text-main: #111827;
            --text-sub: #6B7280;
            --accent: #2563EB; /* Tech Blue */
        }

        body {
            margin: 0;
            overflow-x: hidden;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.8s ease;
        }

        /* --- 3D Canvas --- */
        #canvas-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100vh;
            z-index: 1;
        }

        /* --- HUD Interface --- */
        .hud-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100vh;
            z-index: 10;
            pointer-events: none;
            padding: 40px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .brand {
            font-weight: 700;
            font-size: 20px;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .brand::before {
            content: ''; width: 12px; height: 12px; background: var(--accent); border-radius: 2px;
        }

        .menu-items {
            display: flex;
            gap: 30px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-sub);
        }

        .toolbar-mockup {
            position: absolute;
            left: 50%; bottom: 40px;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 100px;
            display: flex;
            gap: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            border: 1px solid rgba(255,255,255,0.5);
        }
        .tool-icon {
            width: 24px; height: 24px;
            border-radius: 4px;
            background: #E5E7EB;
            transition: 0.3s;
        }
        .tool-icon.active { background: var(--text-main); }

        /* --- Story Text --- */
        .story-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100vh;
            z-index: 5;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 15%;
        }

        .feature-card {
            position: absolute;
            opacity: 0;
            transform: translateY(40px);
            max-width: 480px;
        }

        .tag {
            display: inline-block;
            background: rgba(37, 99, 235, 0.1);
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 6px 12px;
            border-radius: 100px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .headline {
            font-size: 3.5rem;
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 24px;
            letter-spacing: -1px;
        }

        .subtext {
            font-size: 1.125rem;
            line-height: 1.6;
            color: var(--text-sub);
        }

        /* --- Code Overlay --- */
        .code-overlay {
            position: absolute;
            right: -50px; top: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(0,0,0,0.2);
            white-space: pre;
            z-index: -1;
        }

        .scroll-spacer { height: 1400vh; } 
        
        /* Dark Mode */
        body.dark-mode {
            --bg-color: #0B0C0E;
            --text-main: #F9FAFB;
            --text-sub: #9CA3AF;
        }
        body.dark-mode .toolbar-mockup {
            background: rgba(30,30,30,0.8);
            border-color: rgba(255,255,255,0.1);
        }
        body.dark-mode .tool-icon { background: #333; }
        body.dark-mode .tool-icon.active { background: #fff; }

        /* Cursor Mockup */
        .cursor-mockup {
            position: fixed;
            width: 20px; height: 20px;
            background-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M3 3L10.07 19.97L12.58 12.58L19.97 10.07L3 3Z' fill='black' stroke='white' stroke-width='2'/%3E%3C/svg%3E");
            z-index: 20;
            opacity: 0;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <!-- Fake Cursor -->
    <div class="cursor-mockup" id="fake-cursor"></div>

    <!-- HUD -->
    <div class="hud-layer">
        <div class="nav-header">
            <div class="brand">LIMITLESS</div>
            <div class="menu-items">
                <span>Product</span>
                <span>Solutions</span>
                <span>Pricing</span>
                <span style="color:var(--text-main); border-bottom: 1px solid currentColor;">Download</span>
            </div>
        </div>
        
        <div class="toolbar-mockup">
            <div class="tool-icon active" id="icon-pen"></div>
            <div class="tool-icon" id="icon-eraser"></div>
            <div class="tool-icon" id="icon-ruler"></div>
            <div class="tool-icon" id="icon-tag"></div>
            <div class="tool-icon" style="border-radius: 100px; width: 40px; background: var(--accent);"></div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Narrative Content -->
    <div class="story-layer">
        
        <!-- Intro -->
        <div class="feature-card" id="card-1">
            <div class="headline">Reinventing<br>The Canvas.</div>
            <div class="subtext">
                Traditional whiteboards are static. <br>
                We built a <b>living workspace</b> where every tool is an intelligent engine.
            </div>
        </div>

        <!-- Tool 1: Pen -->
        <div class="feature-card" id="card-2" style="align-self: flex-end; text-align: right;">
            <div class="tag">Flow Engine™ 2.0</div>
            <div class="headline">Zero Latency.<br>Fluid Thought.</div>
            <div class="subtext">
                Not just a pixel brush. Our <b>Zero-G Pen</b> uses physics simulation to stabilize your handwriting in real-time.
            </div>
        </div>

        <!-- Tool 2: Eraser -->
        <div class="feature-card" id="card-3">
            <div class="tag">Semantic Erase</div>
            <div class="headline">Personalized<br>Tools.</div>
            <div class="subtext">
                Even the humblest eraser has a soul. Watch as we laser-etch your identity onto the digital sleeve in real-time.
            </div>
        </div>

        <!-- Tool 3: Ruler -->
        <div class="feature-card" id="card-4" style="align-self: center; text-align: center;">
            <div class="tag">Intelligent Alignment</div>
            <div class="headline">Order from Chaos.</div>
            <div class="subtext">
                The <b>Bridge System</b> acts as an invisible grid that snaps your ideas into perfect perspective.
            </div>
        </div>

        <!-- Tool 4: Tag -->
        <div class="feature-card dark-mode" id="card-5" style="max-width: 600px;">
            <div class="tag" style="background:rgba(255,255,255,0.2); color:#fff;">Knowledge Graph</div>
            <div class="headline">Turn Sketches<br>Into Data.</div>
            <div class="subtext" style="color: #9CA3AF;">
                With <b>Braille-Tags</b>, every note has memory. Visualize deadlines and priority directly on the canvas.
            </div>
        </div>
        
        <!-- Finale -->
        <div class="feature-card dark-mode" id="card-6" style="align-self: center; text-align: center;">
            <div class="headline" style="font-size: 4rem;">Limitless.</div>
            <div class="subtext" style="color: #9CA3AF;">The complete toolkit for modern thinkers.</div>
            <div style="margin-top: 30px; padding: 15px 30px; background: #fff; color:#000; display:inline-block; border-radius: 100px; font-weight:600;">
                Start Free Trial ->
            </div>
        </div>

    </div>

    <div class="scroll-spacer"></div>

    <script>
        // --- Config ---
        const CONFIG = {
            bgLight: 0xF3F4F6,
            bgDark: 0x0B0C0E,
            gridColor: 0xE5E7EB,
            accent: 0x2563EB,
            charcoal: 0x374151,
            eraserBody: 0xFFFFFF,
            eraserSleeve: 0xEEEEEE,
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.bgLight);
        scene.fog = new THREE.FogExp2(CONFIG.bgLight, 0.015);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Camera positioned for a natural desk view (approx 25-30 degree angle down)
        camera.position.set(0, 15, 35); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(10, 20, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        const blueLight = new THREE.PointLight(CONFIG.accent, 0.5);
        blueLight.position.set(-10, 5, -10);
        scene.add(blueLight);

        // --- Dot Grid ---
        function createDotGrid() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'transparent'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#CBD5E1';
            ctx.beginPath(); ctx.arc(32, 32, 2, 0, Math.PI*2); ctx.fill();
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(100, 100);
            tex.magFilter = THREE.NearestFilter;

            const geo = new THREE.PlaneGeometry(400, 400);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2;
            return mesh;
        }
        const grid = createDotGrid();
        scene.add(grid);

        // --- Lines System ---
        // 1. Flow Curve
        const curvePath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-3, 0.05, -2),
            new THREE.Vector3(-1.5, 0.05, -0.5),
            new THREE.Vector3(0, 0.05, -2),
            new THREE.Vector3(2, 0.05, 0),
            new THREE.Vector3(4, 0.05, -1)
        ]);
        const curvePoints = curvePath.getPoints(100);
        const curveGeo = new THREE.BufferGeometry().setFromPoints(curvePoints);
        const curveMat = new THREE.LineBasicMaterial({ color: CONFIG.accent, linewidth: 3, transparent: true, opacity: 1 });
        const drawnCurve = new THREE.Line(curveGeo, curveMat);
        drawnCurve.geometry.setDrawRange(0, 0);
        scene.add(drawnCurve);

        // 2. Straight Line
        const linePath = new THREE.LineCurve3(new THREE.Vector3(-4, 0.05, 1), new THREE.Vector3(4, 0.05, 1));
        const linePoints = linePath.getPoints(50);
        const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMat = new THREE.LineBasicMaterial({ color: CONFIG.accent, linewidth: 3 });
        const straightLine = new THREE.Line(lineGeo, lineMat);
        straightLine.geometry.setDrawRange(0, 0);
        scene.add(straightLine);


        // --- Tools ---
        
        // 1. Pen (Ultra-Optimized Sleek Hexagonal Model)
        function createPen() {
            const g = new THREE.Group();
            
            // Materials - Sleek Pro
            const matBody = new THREE.MeshStandardMaterial({ 
                color: 0x202020, // Matte Black body
                roughness: 0.5,
                flatShading: true // Sharp hexagonal edges
            });
            const matGrip = new THREE.MeshStandardMaterial({
                color: 0x151515, // Darker grip
                roughness: 0.8,
                bumpScale: 0.02
            });
            const matMetal = new THREE.MeshStandardMaterial({
                color: 0xcccccc, // Brushed Steel
                roughness: 0.3,
                metalness: 0.8
            });
            const matNib = new THREE.MeshStandardMaterial({
                color: 0x111111, // Dark Graphite
                roughness: 0.9
            });
            const matLight = new THREE.MeshBasicMaterial({ color: CONFIG.accent });

            // 1. Fine Point Nib (Vertex at 0,0,0)
            // Tiny cylinder + cone for precision
            const nibTipGeo = new THREE.CylinderGeometry(0.015, 0.005, 0.05, 8);
            nibTipGeo.translate(0, 0.025, 0); // Tip right at 0
            const nibTip = new THREE.Mesh(nibTipGeo, matNib);
            g.add(nibTip);

            const nibConeGeo = new THREE.CylinderGeometry(0.08, 0.015, 0.25, 16);
            nibConeGeo.translate(0, 0.05 + 0.125, 0); 
            const nibCone = new THREE.Mesh(nibConeGeo, matMetal);
            nibCone.castShadow = true;
            g.add(nibCone);

            // 2. Metal Ferrule (Tapered transition)
            const ferruleGeo = new THREE.CylinderGeometry(0.2, 0.08, 0.4, 32);
            ferruleGeo.translate(0, 0.3 + 0.2, 0);
            const ferrule = new THREE.Mesh(ferruleGeo, matMetal);
            ferrule.castShadow = true;
            g.add(ferrule);

            // 3. Grip Section (Textured/Darker)
            // Slightly thicker than body for ergonomics
            const gripGeo = new THREE.CylinderGeometry(0.21, 0.2, 1.8, 32);
            gripGeo.translate(0, 0.9 + 0.9, 0);
            const grip = new THREE.Mesh(gripGeo, matGrip);
            grip.castShadow = true;
            g.add(grip);

            // 4. LED Status Ring
            const ringGeo = new THREE.CylinderGeometry(0.21, 0.21, 0.04, 32);
            ringGeo.translate(0, 2.7 + 0.02, 0);
            const ring = new THREE.Mesh(ringGeo, matLight);
            g.add(ring);

            // 5. Hexagonal Main Body (Long & Sleek)
            // Radius approx 0.2, Length ~4.5
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 4.5, 6); // 6 segments
            bodyGeo.translate(0, 2.74 + 2.25, 0);
            const body = new THREE.Mesh(bodyGeo, matBody);
            body.castShadow = true;
            g.add(body);

            // 6. Pocket Clip (The detail that makes it a "Pen")
            const clipStemGeo = new THREE.BoxGeometry(0.06, 0.4, 0.15);
            clipStemGeo.translate(0.2, 6.5, 0); // Near top
            const clipStem = new THREE.Mesh(clipStemGeo, matMetal);
            g.add(clipStem);

            const clipArmGeo = new THREE.BoxGeometry(0.04, 2.5, 0.08);
            clipArmGeo.translate(0.25, 5.5, 0); // Extending down
            const clipArm = new THREE.Mesh(clipArmGeo, matMetal);
            g.add(clipArm);

            // 7. End Cap / Button
            const capGeo = new THREE.CylinderGeometry(0.18, 0.2, 0.3, 32);
            capGeo.translate(0, 6.99 + 0.15, 0);
            const cap = new THREE.Mesh(capGeo, matMetal);
            g.add(cap);

            // Important: Set rotation order
            g.rotation.order = 'YXZ'; 

            return g;
        }
        const pen = createPen();
        scene.add(pen);

        // 2. Eraser System (Dynamic Text)
        let eraserTextureCanvas, eraserTextureCtx, eraserTexture;
        
        function createEraserSystem() {
            const g = new THREE.Group();

            const rubber = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.8, 1.8),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.9 })
            );
            rubber.castShadow = true;
            g.add(rubber);

            eraserTextureCanvas = document.createElement('canvas');
            eraserTextureCanvas.width = 512;
            eraserTextureCanvas.height = 256;
            eraserTextureCtx = eraserTextureCanvas.getContext('2d');
            
            eraserTextureCtx.fillStyle = '#f4f4f4';
            eraserTextureCtx.fillRect(0,0,512,256);
            for(let i=0; i<1000; i++) {
                eraserTextureCtx.fillStyle = `rgba(0,0,0,${Math.random()*0.05})`;
                eraserTextureCtx.fillRect(Math.random()*512, Math.random()*256, 2, 2);
            }
            eraserTextureCtx.strokeStyle = '#e0e0e0';
            eraserTextureCtx.lineWidth = 4;
            eraserTextureCtx.strokeRect(0,0,512,256);

            eraserTexture = new THREE.CanvasTexture(eraserTextureCanvas);
            
            const sleeve = new THREE.Mesh(
                new THREE.BoxGeometry(2.6, 0.9, 1.9),
                new THREE.MeshStandardMaterial({ map: eraserTexture, roughness: 0.8 })
            );
            sleeve.position.x = 0.5;
            sleeve.castShadow = true;
            g.add(sleeve);
            
            return g;
        }
        const eraser = createEraserSystem();
        scene.add(eraser);

        // 3. Ruler
        const rulerGroup = new THREE.Group();
        const rulerGlass = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 2), new THREE.MeshPhysicalMaterial({ color: 0xE0F2FE, transmission: 0.9, roughness: 0, thickness: 1.5 }));
        rulerGroup.add(rulerGlass);
        for(let i=-3.5; i<=3.5; i+=0.5) {
            const t = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.8), new THREE.MeshBasicMaterial({ color: CONFIG.accent }));
            t.position.set(i, 0, 0);
            rulerGroup.add(t);
        }
        const ruler = rulerGroup;
        scene.add(ruler);

        // 4. Tag
        const tagGroup = new THREE.Group();
        const tShape = new THREE.Shape();
        tShape.moveTo(0,0); tShape.lineTo(3,0); tShape.lineTo(3.5, 0.5); tShape.lineTo(3, 1); tShape.lineTo(0,1);
        const tGeo = new THREE.ExtrudeGeometry(tShape, { depth: 0.1, bevelEnabled: false });
        const tMat = new THREE.MeshBasicMaterial({ color: CONFIG.accent, transparent: true, opacity: 0.8 });
        const tMesh = new THREE.Mesh(tGeo, tMat);
        tMesh.position.set(-1.75, -0.5, 0);
        tagGroup.add(tMesh);
        const d1 = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xffffff})); d1.position.set(1,0,0.2);
        const d2 = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xffffff})); d2.position.set(1.5,0,0.2);
        tagGroup.add(d1); tagGroup.add(d2);
        const tag = tagGroup;
        scene.add(tag);

        // --- Animation Logic ---
        gsap.registerPlugin(ScrollTrigger);
        
        // Init pos
        pen.position.set(0, 30, 0);
        pen.rotation.set(Math.PI/2, 0, 0); // Flat on side initially
        eraser.position.set(0, 30, 0);
        ruler.position.set(0, 30, 0);
        tag.position.set(0, 30, 0);

        const icons = document.querySelectorAll('.tool-icon');
        function activateIcon(index) {
            icons.forEach((icon, i) => {
                if(index === -1) { icon.classList.remove('active'); return; }
                if(i === index) icon.classList.add('active');
                else icon.classList.remove('active');
            });
        }

        function updateEraserText(progress) {
            if(!eraserTextureCtx) return;
            eraserTextureCtx.fillStyle = '#f4f4f4';
            eraserTextureCtx.fillRect(0,0,512,256);
            for(let i=0; i<200; i++) {
                eraserTextureCtx.fillStyle = `rgba(0,0,0,${Math.random()*0.05})`;
                eraserTextureCtx.fillRect(Math.random()*512, Math.random()*256, 2, 2);
            }
            eraserTextureCtx.strokeStyle = '#e0e0e0';
            eraserTextureCtx.strokeRect(0,0,512,256);

            const revealWidth = progress * 512;
            eraserTextureCtx.save();
            eraserTextureCtx.beginPath();
            eraserTextureCtx.rect(0, 0, revealWidth, 256);
            eraserTextureCtx.clip();

            eraserTextureCtx.translate(256, 128);
            eraserTextureCtx.font = '100px "Ma Shan Zheng", cursive'; 
            eraserTextureCtx.textAlign = 'center';
            eraserTextureCtx.textBaseline = 'middle';
            eraserTextureCtx.fillStyle = '#333'; 
            eraserTextureCtx.shadowColor = "rgba(0,0,0,0.2)";
            eraserTextureCtx.shadowBlur = 4;
            eraserTextureCtx.fillText("云科", 0, 0);
            eraserTextureCtx.restore();

            eraserTexture.needsUpdate = true;
        }


        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: ".scroll-spacer",
                start: "top top",
                end: "bottom bottom",
                scrub: 1,
            }
        });

        // === Scene 1: Intro ===
        tl.to("#card-1", { opacity: 1, y: 0, duration: 2 })
          .to("#card-1", { opacity: 0, y: -50, duration: 2 }, "+=1");

        // === Scene 2: Pen Writing Flow ===
        let penState = { progress: 0 };
        tl.call(() => activateIcon(0))
          // 1. Pen Entry (Fly in holding posture)
          .to(pen.position, { x: -3, y: 2, z: -1, duration: 2 })
          // Initial Pose:
          // Y: Direction (Point leftish)
          // X: Tilt Back ~45-50 deg (Math.PI/3.5)
          // Z: Slant Right ~30 deg (-Math.PI/6)
          .to(pen.rotation, { x: Math.PI/3.5, y: Math.PI, z: -Math.PI/6, duration: 2 }, "<")
          
          .to("#card-2", { opacity: 1, y: 0, duration: 2 }, "-=1")
          
          // 2. Writing
          .to(pen.position, { y: 0.0, duration: 0.5 }) 
          .to(penState, { 
              progress: 1, duration: 4, ease: "none",
              onUpdate: () => {
                  const p = penState.progress;
                  const point = curvePath.getPoint(p);
                  pen.position.set(point.x, point.y + 0.02, point.z); 
                  
                  // Calculate Direction
                  const t = curvePath.getTangent(p);
                  const yaw = Math.atan2(t.x, t.z);
                  
                  // Natural Writing Pose:
                  // Y: Follows path direction (yaw + Math.PI to point tip forward)
                  // X: Fixed tilt back (~50 deg)
                  // Z: Fixed slant right (~30 deg) - "歪着"
                  pen.rotation.set(Math.PI/3.5, yaw + Math.PI, -Math.PI/6);
                  
                  drawnCurve.geometry.setDrawRange(0, Math.floor(p * 100));
              }
          })
          .to(pen.position, { y: 30, duration: 2 })
          .to("#card-2", { opacity: 0, y: -50, duration: 2 }, "<");

        // === Scene 3: Eraser ===
        let writeState = { p: 0 };
        
        tl.call(() => activateIcon(1))
          .call(() => updateEraserText(0)) 
          .to(eraser.position, { x: 0, y: 1.5, z: 0, duration: 2 }, "-=1")
          .to(eraser.rotation, { x: Math.PI/4, y: 0, z: 0, duration: 2 }, "<")
          .to("#card-3", { opacity: 1, y: 0, duration: 2 })
          
          // Pen Returns to Sign
          .to(pen.position, { x: -1.5, y: 2.5, z: 0.8, duration: 1.5 }) 
          .to(pen.rotation, { x: Math.PI/3.5, y: Math.PI/2, z: -Math.PI/6, duration: 1 }, "<")
          
          // Signing Animation
          .to(writeState, {
              p: 1, duration: 4, ease: "none",
              onUpdate: () => {
                  const progress = writeState.p;
                  updateEraserText(progress);
                  
                  const writeX = -1.0 + (progress * 2.5); 
                  const writeZ = Math.sin(progress * 30) * 0.2; 
                  
                  pen.position.set(writeX + 0.5, 2.2, writeZ + 0.5); 
                  
                  // Wiggle while signing
                  pen.rotation.set(Math.PI/3.5 + Math.sin(progress * 40)*0.1, Math.PI/2, -Math.PI/6); 
              }
          })

          .to(pen.position, { y: 30, duration: 1 })
          
          // 5. Eraser Action (UPDATED: TILTED ERASE)
          // Rotate to stand on corner: Tilt Z by 60deg (PI/3)
          .to(eraser.rotation, { x: 0, y: 0, z: Math.PI / 3, duration: 0.5 }) 
          // Position adjustment: Lift Y so the corner touches paper (Approx 1.8)
          .to(eraser.position, { x: -1, y: 1.8, z: -0.5, duration: 0.5 }, "<") 
          // Vigorously scrub X/Z with slight Y wobble for pressure
          .to(eraser.position, { x: 1, y: 1.85, z: 0.5, duration: 0.2, yoyo: true, repeat: 5, ease: "power1.inOut" }) 
          .to(drawnCurve.material, { opacity: 0, duration: 1.0 }, "<")

          .to(eraser.position, { y: 30, duration: 2 })
          .to("#card-3", { opacity: 0, y: -50, duration: 2 }, "<");

        // === Scene 4: Ruler ===
        tl.call(() => activateIcon(2))
          .to(ruler.position, { x: 0, y: 0.2, z: 0, duration: 2 })
          .to("#card-4", { opacity: 1, y: 0, duration: 2 })
          .to(grid.material, { opacity: 0.6, duration: 2 }, "<")
          
          // Reset Pen
          .set(pen.position, { x: -4.5, y: 2, z: 1.5 })
          // Ruler Line Pose
          .set(pen.rotation, { x: Math.PI/3.5, y: Math.PI/2, z: -Math.PI/6 }) 
          
          .to(pen.position, { y: 0.05, duration: 1 }) 
          .to(pen.position, { 
              x: 4.5, duration: 3, ease: "power1.inOut", 
              onUpdate: function(){ straightLine.geometry.setDrawRange(0, Math.floor(this.progress()*50)); } 
           })
          .to([ruler.position, pen.position], { y: 30, duration: 2 })
          .to("#card-4", { opacity: 0, y: -50, duration: 2 }, "<");

        // === Scene 5: Finale ===
        tl.call(() => activateIcon(3))
          .to("body", { backgroundColor: "#0B0C0E", duration: 2 })
          .to("body", { className: "dark-mode" }, "<") 
          .to(scene.fog.color, { r: 0.04, g: 0.04, b: 0.05, duration: 2 }, "<")
          .to(scene.background, { r: 0.04, g: 0.04, b: 0.05, duration: 2 }, "<")
          .to(grid.material, { opacity: 0.05, duration: 2 }, "<") 
          
          .to(tag.position, { x: 0, y: 2, z: 0, duration: 2 }, "-=1")
          .to("#card-5", { opacity: 1, y: 0, duration: 2 })
          .to(tag.rotation, { y: Math.PI * 2, duration: 8, ease: "none" }, "<")
          .to("#card-5", { opacity: 0, y: -50, duration: 1 }, "+=2")
          .to("#card-6", { opacity: 1, y: 0, duration: 1 })

          .call(() => activateIcon(-1))
          .to(pen.position, { x: -5, y: 2, z: 0, duration: 2 }, "<")
          .to(pen.rotation, { x: Math.PI/4, y: 0, z: Math.PI/4, duration: 2 }, "<") 
          .to(eraser.position, { x: 5, y: 2, z: 0, duration: 2 }, "<")
          .to(eraser.rotation, { x: Math.PI/4, y: -0.5, z: 0, duration: 2 }, "<")
          .to(ruler.position, { x: 0, y: -2, z: 2, duration: 2 }, "<")
          .to(ruler.rotation, { x: -Math.PI/6, y: 0, z: 0, duration: 2 }, "<");


        // --- Loop ---
        const clock = new THREE.Clock();
        // Define cursor variable to prevent ReferenceError
        const cursor = document.getElementById('fake-cursor');

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            if(pen.position.y > 25) { 
            } else if(pen.position.y < 5 && pen.position.y > 0.1) {
                 pen.position.y += Math.sin(time * 3) * 0.0005;
            }

            if(eraser.position.y < 20) eraser.position.y += Math.cos(time * 2.5) * 0.001;
            if(tag.position.y < 20) tag.position.y += Math.sin(time * 3) * 0.001;
            if(ruler.position.y < 20) ruler.position.y += Math.cos(time * 1.5) * 0.001;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        document.addEventListener('mousemove', (e) => {
            if (cursor) gsap.to(cursor, { x: e.clientX, y: e.clientY, duration: 0.2 });
        });
        document.addEventListener('mouseenter', () => { if (cursor) cursor.style.opacity = 1; });
        document.addEventListener('mouseleave', () => { if (cursor) cursor.style.opacity = 0; });

    </script>
</body>
</html>
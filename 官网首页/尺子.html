<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Limitless Ruler | 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #F3F4F6;
            font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            outline: none;
        }

        .ui-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.08);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            align-items: center;
            white-space: nowrap;
        }

        .text-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #E5E7EB;
            background: #fff;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .text-btn:hover {
            background: #F9FAFB;
            border-color: #D1D5DB;
            transform: translateY(-1px);
        }
        .text-btn.active {
            background: #111827;
            color: #fff;
            border-color: #111827;
        }

        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; border:1px solid rgba(0,0,0,0.1); }
        .label { font-size: 12px; color: #9CA3AF; font-weight: 500; margin-right: 8px; text-transform: uppercase; }
        
        .instruction {
            position: absolute; top: 40px; width: 100%; text-align: center;
            color: #9CA3AF; font-size: 12px; pointer-events: none; letter-spacing: 2px; font-weight: 600;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
</head>
<body>

    <div class="instruction">INTERACTIVE RULER • DRAG TO ROTATE</div>

    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <span class="label">Material</span>
        <button class="text-btn active" onclick="updateMaterial('Frost')">
            <span class="dot" style="background:#A5F3FC"></span> 磨砂亚克力
        </button>
        <button class="text-btn" onclick="updateMaterial('Metal')">
            <span class="dot" style="background:#94A3B8"></span> 拉丝金属
        </button>
        <button class="text-btn" onclick="updateMaterial('Midnight')">
            <span class="dot" style="background:#0F172A"></span> 黑金流光
        </button>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF3F4F6);
        
        // 广角镜头增加近距离的透视冲击力
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Lighting (Studio Setup) ---
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const roomEnv = new THREE.Scene();
        const boxMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
        roomEnv.add(new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), boxMat));
        // 长条形灯光，利于展示尺子的反光
        const light1 = new THREE.Mesh(new THREE.PlaneGeometry(8, 2), new THREE.MeshBasicMaterial({color:0xffffff}));
        light1.position.set(0, 4.9, 0); light1.rotation.x = Math.PI/2; roomEnv.add(light1);
        scene.environment = pmremGenerator.fromScene(roomEnv).texture;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.radius = 3;
        scene.add(mainLight);

        const shadowPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.ShadowMaterial({ opacity: 0.15, color: 0x111827 })
        );
        shadowPlane.rotation.x = -Math.PI / 2;
        shadowPlane.position.y = -0.15; // 贴近尺子底部
        shadowPlane.receiveShadow = true;
        scene.add(shadowPlane);

        // --- Ruler Creation ---

        let rulerMesh;
        let rulerCanvas, rulerCtx, rulerTexture;

        function createRuler() {
            const width = 8;
            const height = 0.15; // 厚度
            const depth = 1.5;   // 宽度

            // 1. 几何体：带圆角的长方体 (更真实)
            // 手动创建一个稍有厚度的Box
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            // 2. 动态纹理 (刻度线)
            rulerCanvas = document.createElement('canvas');
            rulerCanvas.width = 2048;
            rulerCanvas.height = 512;
            rulerCtx = rulerCanvas.getContext('2d');
            
            // 默认绘制
            drawRulerTexture('#111827', false); // 黑字，透明背景

            rulerTexture = new THREE.CanvasTexture(rulerCanvas);
            rulerTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            // 3. 材质 (初始: 磨砂亚克力)
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xE0F2FE,     // 浅蓝着色
                transmission: 0.95,  // 高透光
                opacity: 1,
                metalness: 0.0,
                roughness: 0.2,      // 磨砂感
                thickness: 1.5,      // 折射厚度
                clearcoat: 1.0,      // 表面光泽
                clearcoatRoughness: 0.1,
                map: rulerTexture,   // 刻度贴图
                transparent: true
            });

            rulerMesh = new THREE.Mesh(geometry, material);
            rulerMesh.castShadow = true;
            // 玻璃材质通常不接收阴影，或者需要特殊处理，这里让它接收以增加真实感
            rulerMesh.receiveShadow = true; 

            scene.add(rulerMesh);
        }

        // --- 刻度绘制逻辑 ---
        function drawRulerTexture(color, isDarkBg) {
            const ctx = rulerCtx;
            const w = 2048;
            const h = 512;

            // 清空
            ctx.clearRect(0, 0, w, h);

            // 如果是金属或深色模式，可能需要背景色
            if (isDarkBg) {
                ctx.fillStyle = '#0F172A'; // 深色底
                ctx.fillRect(0, 0, w, h);
            } else {
                // 透明背景用于玻璃模式
                // 不填充背景
            }

            ctx.fillStyle = color;
            ctx.strokeStyle = color;

            // 绘制刻度
            const startX = 100;
            const endX = w - 100;
            const totalUnits = 20; // 假设是20cm尺子
            const step = (endX - startX) / totalUnits;

            ctx.lineWidth = 4;
            ctx.beginPath();
            
            // 主横线
            // ctx.moveTo(startX, 100);
            // ctx.lineTo(endX, 100);
            
            for(let i=0; i<=totalUnits; i++) {
                const x = startX + i * step;
                
                // 长刻度 (cm)
                ctx.fillRect(x-2, 0, 4, 120); // 从上边缘向下画

                // 数字
                ctx.font = 'bold 50px "JetBrains Mono"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(i.toString(), x, 140);

                // 短刻度 (mm)
                if (i < totalUnits) {
                    for(let j=1; j<10; j++) {
                        const mmX = x + (step/10)*j;
                        const h = (j===5) ? 80 : 50; // 5mm处稍长
                        ctx.fillRect(mmX-1, 0, 2, h);
                    }
                }
            }

            // Logo "云科"
            ctx.save();
            ctx.translate(w/2, h - 120);
            ctx.font = 'bold 140px "Ma Shan Zheng"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 如果是深色背景，加点光晕
            if(isDarkBg) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
            }
            
            ctx.fillText("云科", 0, 0);
            
            ctx.font = '40px "Inter"';
            ctx.globalAlpha = 0.7;
            ctx.fillText("PRECISION INSTRUMENT", 0, 80);
            ctx.restore();

            if(rulerTexture) rulerTexture.needsUpdate = true;
        }

        createRuler();

        // --- 材质切换逻辑 ---
        window.updateMaterial = function(type) {
            // 简单的旋转动画反馈
            gsap.to(rulerMesh.rotation, { y: rulerMesh.rotation.y + Math.PI, duration: 1, ease: "power2.inOut" });

            if (type === 'Frost') {
                // 1. 磨砂亚克力
                drawRulerTexture('#111827', false); // 黑字，透明底
                rulerMesh.material = new THREE.MeshPhysicalMaterial({
                    color: 0xE0F2FE,
                    transmission: 0.95,
                    opacity: 1,
                    metalness: 0.0,
                    roughness: 0.2,
                    thickness: 1.5,
                    clearcoat: 1.0,
                    map: rulerTexture,
                    transparent: true
                });
            } else if (type === 'Metal') {
                // 2. 拉丝金属
                drawRulerTexture('#333333', false); // 深灰字
                // 金属不需要透明底，但为了复用Texture逻辑，我们可以给Mesh加个底色或者在Draw里画底色
                // 这里我们在Draw里画底色更可控，或者直接用Mesh材质属性
                // 为了简单，金属尺通常不透光，我们画一个银色背景
                
                // 重新绘制带背景的纹理
                const ctx = rulerCtx;
                ctx.fillStyle = '#E2E8F0'; // 银灰底
                ctx.fillRect(0,0,2048,512);
                drawRulerTexture('#1E293B', false); // 重新画字(刚才被覆盖了，其实应该改draw函数逻辑，这里简化处理)
                // *Hack*: 上面的 drawRulerTexture 是 clearRect 的，所以我们要手动补一下背景逻辑
                // 让我们修改一下 drawRulerTexture 的调用方式更好
                
                // 修正：直接用标准材质模拟铝合金
                rulerMesh.material = new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    map: rulerTexture, // 此时是透明底黑字
                    roughness: 0.4,
                    metalness: 0.9,
                    envMapIntensity: 1.5,
                    transparent: true // 纹理是透明的，叠加在金属色上
                });
                // 金属不需要透明背景的纹理？
                // 实际上，如果纹理是透明的，Mesh本身颜色会透出来。
                // 我们保持 Texture 是透明底黑字，Mesh 设为白色金属，效果就是银底黑字。
            } else if (type === 'Midnight') {
                // 3. 黑金流光
                drawRulerTexture('#FCD34D', true); // 金字，深色底
                rulerMesh.material = new THREE.MeshPhysicalMaterial({
                    color: 0x000000,
                    map: rulerTexture,
                    roughness: 0.2,
                    metalness: 0.5,
                    transmission: 0.6, // 半透黑玻璃
                    thickness: 2.0,
                    clearcoat: 1.0
                });
            }

            document.querySelectorAll('.text-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        controls.addEventListener('start', () => { controls.autoRotate = false; });

    </script>
</body>
</html>